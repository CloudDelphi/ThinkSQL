package uk.co.thinksql;

/*       ThinkSQL Relational Database Management System
              Copyright Â© 2000-2012  Greg Gaughan
                  See LICENCE.txt for details
*/

import java.math.BigDecimal;

import java.io.*;
import java.sql.*;

import uk.co.thinksql.StatementSQL.*;
import uk.co.thinksql.Global.*;
import uk.co.thinksql.GlobalUtil.*;

/**
 * <P>A ResultSet provides access to a table of data generated by
 * executing a Statement. The table rows are retrieved in
 * sequence. Within a row its column values can be accessed in any
 * order.
 * 
 * <P>A ResultSet maintains a cursor pointing to its current row of
 * data.  Initially the cursor is positioned before the first row.
 * The 'next' method moves the cursor to the next row.
 *
 * <P>The getXXX methods retrieve column values for the current
 * row.  You can retrieve values either using the index number of the
 * column, or by using the name of the column.  In general using the 
 * column index will be more efficient.  Columns are numbered from 1.
 *
 * <P>For maximum portability, ResultSet columns within each row should be
 * read in left-to-right order and each column should be read only once.
 *
 * <P>For the getXXX methods, the JDBC driver attempts to convert the
 * underlying data to the specified Java type and returns a suitable
 * Java value.  See the JDBC specification for allowable mappings
 * from SQL types to Java types with the ResultSet.getXXX methods.
 *
 * <P>Column names used as input to getXXX methods are case insensitive.
 * When performing a getXXX using a column name, if several columns have
 * the same name, then the value of the first matching column will be
 * returned.
 *
 * <P>A ResultSet is automatically closed by the Statement that
 * generated it when that Statement is closed, re-executed, or is used
 * to retrieve the next result from a sequence of multiple results.
 * 
 * <P>The number, types and properties of a ResultSet's columns are
 * provided by the ResulSetMetaData object returned by the getMetaData
 * method.
 *
 * @see Statement#executeQuery 
 * @see Statement#getResultSet 
 * @see ResultSetMetaData 
 */

public class ResultSetSQL implements java.sql.ResultSet {

  public StatementSQL fStmt;
  
  
  private byte[] cursorBuf;
  private short cursorNull;
  
  private short functionId;
  private short resultCode;
  private int resultErrCode;
  private String resultErrText;
  
  int rowCount=0;
  

  public ResultSetSQL(StatementSQL stmt) {
    fStmt=stmt;     
  }

  /**
   * A ResultSet is initially positioned before its first row; the
   * first call to next makes the first row the current row; the
   * second call makes the second row the current row, etc. 
   *
   * <P>If an input stream from the previous row is open, it is
   * implicitly closed. The ResultSet's warning chain is cleared
   * when a new row is read.
   *
   * @return true if the new current row is valid; false if there
   * are no more rows 
   */
  public boolean next() throws java.sql.SQLException {
    int offsetSize=0;
    int colCount;
    int rowCount;
    int row;
    short sqlRowStatus;
    short rowStatusExtra;
    short colStatusExtra;
    short setStatusExtra;
    
    int i;
    short rn;
    
    short tempNull;
    
    
    if (fStmt!=null) {
      /*call server fetchScroll*/
      //todo Replace all AS with casts - speed
        fStmt.fCon.marshalBuffer.ClearToSend();
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer is now empty after the clearToSend,
         we can omit the error result checking in the following put() calls = speed
        */
        fStmt.fCon.marshalBuffer.putFunction(Global.SQL_API_SQLFETCHSCROLL);
        fStmt.fCon.marshalBuffer.putSQLHSTMT(fStmt.ServerStatementHandle); //pass server statement ref
        fStmt.fCon.marshalBuffer.putSQLSMALLINT(Global.SQL_FETCH_NEXT);
        fStmt.fCon.marshalBuffer.putSQLINTEGER(0); //todo check not used for fetch_next!
        if (fStmt.fCon.marshalBuffer.Send()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
  
        /*Wait for response*/
        if (fStmt.fCon.marshalBuffer.Read()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer has been read in total by the Read above because its size was known,
         we can omit the error result checking in the following get() calls = speed
        */
        functionId=fStmt.fCon.marshalBuffer.getFunction();
        if (functionId!=Global.SQL_API_SQLFETCHSCROLL) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        //resultCode comes later
        /*retrieve any result data*/
  
        /*Read row count*/
        rowCount=fStmt.fCon.marshalBuffer.getSQLUINTEGER();
        //todo? check rowCount=array_size - no reason why not... could assume? - but dangerous
        /*Initialise the count of non-empty rows in the application's buffer*/
        //if s.ard.desc_rows_processed_ptr<>nil then
        //  pSQLuINTEGER(s.ard.desc_rows_processed_ptr)^:=0; //we increment this each time we get a 'real' result row
        //might be slightly quicker (less safe) to set to rowCount now & decrement if we get an empty row - speed?
  
        //todo: note pSQLINTEGER(intPtr)^:=x is safer than SQLINTEGER(intPtr^):=x
        // - check this is true & if so make sure we use this everywhere!
  
        //GlobalUtil.logError("SQLFetchScroll returns "+rowCount+" rows");
  
        //if s.ard.desc_bind_offset_ptr<>nil then
        //  offsetSize:=SQLINTEGER(s.ard.desc_bind_offset_ptr^) //get deferred value
        //else
          offsetSize=0; //todo assert rowCount/array_size = 1 - else where do we put the data!!!!
   
        setStatusExtra=0; //no conversion errors
  
        for (row=1;row<=rowCount;row++) {
          /*Now get the col count & data for this row*/
          colCount=fStmt.fCon.marshalBuffer.getSQLINTEGER();
          //GlobalUtil.logError("SQLFetchScroll returns "+colCount+"column data");
          //todo assert s.ard.desc_count<=colCount ?
          //todo now use get with result checking!!!
  
          rowStatusExtra=0; //no conversion errors
          rn=0; //initialise in case 0 columns - i.e. DBXpress with no pre-binding
          //todo remove! inc(colCount); //assume 0 based count... todo remove? debug
  
          i=0;
          while (i<=colCount-1) {
            //todo maybe server should sort by col-ref before sending?, although we sort here via getRecord...
            rn=fStmt.fCon.marshalBuffer.getSQLSMALLINT();
            
            
            if (rn<=fStmt.col.length) {
              //todo if this has just been created, then problem - can't happen if we assert desc_count<colCount above?
                //for dbExpress stub: leave data collecting to column access
                /*Get the null flag*/
                tempNull=fStmt.fCon.marshalBuffer.getSQLSMALLINT();
                if (tempNull==Global.SQL_TRUE) {
                }
                else {
                  //Note: we only get length+data if not null
                    //note: we don't add \0 here
                    fStmt.col[rn].data=fStmt.fCon.marshalBuffer.getpDataSDWORD();
                }
  
  
                /*todo re-instate this code when we need speed!
  
                //todo use a get routine that doesn't add \0 = waste of space at such a raw level?
                //todo check casts are ok
                //todo assert desc_data_ptr<>nil! surely not every time!?
                {Get the data}
                //we need to store pointer in a temp var cos we need to pass as var next (only because routine needs to allow Dynamic allocation - use 2 routines = speed)
                //elementSize may not be original desc_octet_length if fixed-length data-type, but bindCol fixes it for us
                if s.ard.desc_bind_type=SQL_BIND_BY_COLUMN then //column-wise //todo move this if outside loop -speed
                  dataPtr:=pUCHAR(SQLHDESC(desc_data_ptr)+offsetSize+( (row-1)* desc_octet_length))
                else //row-wise
                  dataPtr:=pUCHAR(SQLHDESC(desc_data_ptr)+offsetSize+( (row-1)* s.ard.desc_bind_type));
  
                //todo convert from server to c type (i.e. from IRD to ARD) ******
                // - note do before we modify client's buffer area - may be too small!
                if s.ird.getRecord(rn,Idr,True)<>ok then
                begin
                  //error, skip this column: need to consume the rest of this column definition anyway -> sink
                  //todo or, could abort the whole routine instead?
                  //note: currently getRecord cannot fail!
                  {$IFDEF DEBUGDETAIL}
                  log(format('SQLFetchScroll failed getting IRD desc record %d - rest of column data abandoned...',[rn])); //todo debug error only - remove
                  {$ENDIF}
                  result:=SQL_ERROR;
                  s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
                  exit; //todo: just for now!
                end;
  
                {Get the null flag}
                if getSQLSMALLINT(tempNull)<>ok then
                begin
                  result:=SQL_ERROR;
                  s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
                  exit;
                end;
                if tempNull=SQL_TRUE then
                begin
                  if desc_indicator_pointer<>nil then
                  begin
                    if s.ard.desc_bind_type=SQL_BIND_BY_COLUMN then //column-wise //todo move this if outside loop -speed
                      lenPtr:=pSQLINTEGER(longint(desc_indicator_pointer)+offsetSize+( (row-1)* sizeof(SQLINTEGER)))
                    else //row-wise
                      lenPtr:=pSQLINTEGER(longint(desc_indicator_pointer)+offsetSize+( (row-1)* s.ard.desc_bind_type));
  
                    SQLINTEGER(lenPtr^):=SQL_NULL_DATA
                  end
                  else
                  begin
                    result:=SQL_ERROR;
                    s.diagnostic.logError(ss22002,fail,'',row,rn); //todo check result
                    exit; //todo continue with next row!
                  end;
                  tempsdw:=0; //we only zeroise this for the debug message below - todo remove: speed
                end
                else
                begin
                  //Note: we only get length+data if not null
                  //note: SQL_C_DEFAULT could be dangerous - we assume user knows what they're doing!
                  if not isBinaryCompatible(desc_concise_type,Idr.desc_concise_type) then
                  begin //conversion required
                    {We read the 1st part, the length, of the field}
                    if getSDWORD(tempsdw)<>ok then
                    begin
                      result:=SQL_ERROR;
                      s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
                      exit;
                    end;
                    {Remember any result (error or warning) to add to rowStatus returned from server}
                    colStatusExtra:=getAndConvert(desc_concise_type,Idr, dataPtr,desc_octet_length,
                                    (s.owner as Tdbc).Marshal,tempsdw, s.diagnostic,row,rn);
                    if colStatusExtra<>ok then
                      if rowStatusExtra=0 then
                        rowStatusExtra:=colStatusExtra; //note: we only retain the 1st warning or error (todo check ok with standard)
                                                        //(although multiple diagnostic error may have been stacked)
  
                    //todo ensure that if a fixed-size result is null, the get in getandconvert doesn't read too much!!!
                    //********* i.e. server should always return a int/float value even if null
                    //          or we should read null flag first before reading data
                    //          or getandconvert should not get if tempsdw=0 is passed!
                    //     Note: we do the 3rd option - check works ok...
  
                    //todo check no need: marshal.skip(tempsdw); //just read by another routine!
                  end
                  else
                  begin //no conversion required
                    //note: we don't add \0 here
                    if getpDataSDWORD(dataPtr,desc_octet_length,tempsdw)<>ok then
                    begin
                      result:=SQL_ERROR;
                      s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
                      exit;
                    end;
                  end;
  
                  //todo: maybe this should be outside this else:
                  //  do we set the length if we got null???? check spec.!
                  // - the len + null flag are usually the same thing!
                  // so I suppose if they're not, we should set the length???? or not????!
  
                  {Set the length to tempsdw - may have been modified by conversion routines}
                  //todo maybe don't set the desc_octet_length_pointer if null will be set below?
                  if desc_octet_length_pointer<>nil then
                  begin
                    if s.ard.desc_bind_type=SQL_BIND_BY_COLUMN then //column-wise //todo move this if outside loop -speed
                      lenPtr:=pSQLINTEGER(longint(desc_octet_length_pointer)+offsetSize+( (row-1)* sizeof(SQLINTEGER)))
                    else //row-wise
                      lenPtr:=pSQLINTEGER(longint(desc_octet_length_pointer)+offsetSize+( (row-1)* s.ard.desc_bind_type));
  
                    SQLINTEGER(lenPtr^):=tempsdw;
                  end;
                end;
              */
  
                //GlobalUtil.logError("next read past column "+rn+" data: "+fStmt.col[rn].data+/* todo fStmt.col[rn].data.length*/" bytes, null="+tempNull);
              
            }
            else {
              //error, skip this column: need to consume the rest of this column definition anyway -> sink
              //todo or, could abort the whole routine instead?
              //note: currently getRecord cannot fail!
              GlobalUtil.logError("next failed getting record "+rn+" - rest of column data abandoned..."); //todo debug error only - remove
              throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed); //todo: just for now!
            }
            
  
            i++;
          }
          /*get row status*/
          sqlRowStatus=fStmt.fCon.marshalBuffer.getSQLUSMALLINT();
          //GlobalUtil.logError("next read past row status "+rn+","+sqlRowStatus); //todo debug only - remove & assumes null terminated pCHAR! which it is from get routines...
          /*If there was a conversion error, then we set the SQLrowStatus to it
           todo - check ok with standard!*/
          if (rowStatusExtra!=0) {
            sqlRowStatus=rowStatusExtra; //todo: maybe we should only if sqlRowStatus is 'OK'?
            if (setStatusExtra==0) {
              setStatusExtra=rowStatusExtra;
            }
          }
          //if s.ard.desc_array_status_ptr<>nil then
          //begin
            //todo remove & statusPtr var: statusPtr:=pSQLUSMALLINT(longint(desc_array_status_ptr)+( (row-1)* sizeof(SQLUSMALLINT)))
          //  SQLUSMALLINT(pSQLUSMALLINT(longint(s.ard.desc_array_status_ptr)+( (row-1)* sizeof(SQLUSMALLINT)))^):=sqlRowStatus;
          //end;
          /*Add to the count of non-empty rows in the application's buffer*/
          //if sqlRowStatus<>SQL_ROW_NOROW then
          //  if s.ard.desc_rows_processed_ptr<>nil then
          //    inc(pSQLuINTEGER(s.ard.desc_rows_processed_ptr)^); //we increment this each time we get a 'real' result row
        }
  
        resultCode=fStmt.fCon.marshalBuffer.getRETCODE();
        //todo we should set to SQL_SUCCESS_WITH_INFO if any rowStatus just had a problem - i.e a conversion problem
        // since server wouldn't have known...
  
        //todo remove result:=resultCode; //pass it on //todo need to pass EOF properly for DBX!!!!
        //GlobalUtil.logError("next returns "+resultCode);
  
        //todo check resultCode=SQL_SUCCESS - any point? can the server refuse?
        /*if error, then get error details: local-number, default-text*/
        int errCount=fStmt.fCon.marshalBuffer.getSQLINTEGER(); //error count
        if (resultCode==Global.SQL_ERROR) {
          for (int err=1;err<=errCount;err++) {
            resultErrCode=fStmt.fCon.marshalBuffer.getSQLINTEGER();
            resultErrText=fStmt.fCon.marshalBuffer.getpUCHAR_SWORD();
            GlobalUtil.logError("server error="+resultErrText);
          }
          //todo remove: never will happen: exit;
        }
  
        /*If server returned SQL_SUCCESS, but we just encountered a conversion warning/error
         then modify the result code to SQL_SUCCESS_WITH_INFO as per ODBC spec.*/
        //if setStatusExtra<>0 then
        //  if resultCode=SQL_SUCCESS then
        //    resultCode:=SQL_SUCCESS_WITH_INFO;
  
        /*todo remove N/A to DBX
        case resultCode of
          SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA:
          begin
            if s.state=S5 then
              s.state:=S6;
          end; {SQL_SUCCESS, SQL_SUCCESS_WITH_INFO}
          SQL_STILL_EXECUTING:
          begin
            s.state:=S11;
          end; {SQL_STILL_EXECUTING}
        else
          //todo what if SQL_ERROR?
          //(else) should never happen!? - it can if 1 row returned & it was an error row... //todo
        end; {case}
        */
  
        /*Since DBX cursors can be detached from their commands, i.e. metaData results
         maybe we should closeCursor here? or on cursor destroy?*/
  
    
      return (resultCode!=Global.SQL_NO_DATA);  
    }
    else {
      return false; //handle missing parent for metaData stub-tests
    }
  }

  public boolean readRaw(int columnNumber) throws java.sql.SQLException {
  //todo HERE!: put in another class? or protect at least!
    int colCount;
    int i;
    short rn;
    short cursorsdw;
    short sqlRowStatus;
    
    if (columnNumber<=fStmt.colCount) {
      //call server getData
        fStmt.fCon.marshalBuffer.ClearToSend();
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer is now empty after the clearToSend,
         we can omit the error result checking in the following put() calls = speed
        */
        fStmt.fCon.marshalBuffer.putFunction(Global.SQL_API_SQLGETDATA);
        fStmt.fCon.marshalBuffer.putSQLHSTMT(fStmt.ServerStatementHandle); //pass server statement ref
        fStmt.fCon.marshalBuffer.putSQLSMALLINT((short)columnNumber);
        if (fStmt.fCon.serverCLIversion>=93) { //restrict result to client buffer size chunks: expect client to repeatedly call this routine
          i=2147483647; //cast //todo ok? make infinite?
          fStmt.fCon.marshalBuffer.putSQLUINTEGER(i);
        }
        if (fStmt.fCon.marshalBuffer.Send()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
  
        /*Wait for response*/
        if (fStmt.fCon.marshalBuffer.Read()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer has been read in total by the Read above because its size was known,
         we can omit the error result checking in the following get() calls = speed
        */
        functionId=fStmt.fCon.marshalBuffer.getFunction();
        if (functionId!=Global.SQL_API_SQLGETDATA) {
          GlobalUtil.logError("Failed functionId="+functionId);
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        //resultCode comes later
        //retrieve any result data
         
        //Read row count
        int rowCount=fStmt.fCon.marshalBuffer.getSQLUINTEGER();
        //todo? assert rowCount=1 - only here to keep similar protocol as fetchScroll (& maybe future use)
  
        //log(format('SQLGetData returns %d rows',[rowCount]),vDebug);
        //GlobalUtil.logError("SQLGetData returns "+rowCount+" rows");
  
        int setStatusExtra=0; //no conversion errors
  
        for (int row=1; row<=rowCount; row++) { //todo remove- not needed, but no harm either...
          //Now get the col count & data for this row
          colCount=fStmt.fCon.marshalBuffer.getSQLINTEGER();
          //todo? again assert colCount=1 - only here to keep similar protocol as fetchScroll (& maybe future use)
          //log(format('SQLGetData returns %d column data',[colCount]),VDebug);
          //GlobalUtil.logError("SQLGetData returns "+colCount+" column data");
          //todo now use get with result checking!!!
  
          i=0;
          while (i<=colCount-1) { //todo remove- not needed, but no harm either...
            //todo maybe server should sort by col-ref before sending?, although we sort here via getRecord...
            rn=fStmt.fCon.marshalBuffer.getSQLSMALLINT();
  
            //todo assert than rn=ColumnNumber that we just sent!
            //log(format('SQLGetData reading returned column %d (should be =%d)',[rn,ColumnNumber]),vDebug); //todo debug only - remove!
  
            //todo use a get routine that doesn't add \0 = waste of space at such a raw level?
            //todo check casts are ok
            //todo assert TargetValue<>nil!
            /*Get the data*/
            //we need to store pointer in a temp var cos we need to pass as var next (only because routine needs to allow Dynamic allocation - use 2 routines = speed)
            //todo remove: dataPtr:=Value;
  
            //todo convert from server to c type (i.e. from IRD to ARD) ******
            // - note do before we modify client's buffer area - may be too small!
            if (rn>(fStmt.col.length+1)) { //todo safer to check if rn<>iFldNum?
              //error, skip this column: need to consume the rest of this column definition anyway -> sink
              //todo or, could abort the whole routine instead?
              //note: currently getRecord cannot fail!
              GlobalUtil.logError("SQLGetData failed getting record "+rn+" - rest of column data abandoned...");
              throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
            }
  
            /*Get the null flag*/
            cursorNull=fStmt.fCon.marshalBuffer.getSQLSMALLINT();
            if (cursorNull==Global.SQL_TRUE) {
              //cursorsdw=0; //we only zeroise this for the debug message below - todo remove: speed
              cursorBuf=null;
            }
            else
            {
              //Note: we only get length+data if not null
              /*todo remove: we ca assume the type
              //note: SQL_C_DEFAULT could be dangerous - we assume user knows what they're doing!
              if not isBinaryCompatible(TargetType,Idr.desc_concise_type) then
              begin //conversion required
                {We read the 1st part, the length, of the field}
                if getSDWORD(tempsdw)<>ok then
                begin
                  result:=SQL_ERROR;
                  s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
                  exit;
                end;
                {Remember any result (error or warning) to add to setStatusExtra returned from server
                 Note: we assume we only deal with 1 row x 1 column here, i.e. we overwrite the setStatusExtra}
                setStatusExtra:=getAndConvert(TargetType,Idr, dataPtr,BufferLength,
                                (s.owner as Tdbc).Marshal,tempsdw, s.diagnostic,row,rn);
  
                //todo ensure that if a fixed-size result is null, the get in getandconvert doesn't read too much!!!
                //********* i.e. server should always return a int/float value even if null
                //          or we should read null flag first before reading data
                //          or getandconvert should not get if tempsdw=0 is passed!
                //     Note: we do the 3rd option - check works ok...
  
                //todo check no need: marshal.skip(tempsdw); //just read by another routine!
              end
              else
              */
              //no conversion required
                cursorBuf=fStmt.fCon.marshalBuffer.getpDataSDWORD(); //was getpUCHAR_SDWORD(); for Delphi
  
              /*todo remove
              //todo: maybe this should be outside this else:
              //  do we set the length if we got null???? check spec.!
              // - the len + null flag are usually the same thing!
              // so I suppose if they're not, we should set the length???? or not????!
  
              {Set the length to tempsdw - may have been modified by conversion routines}
              //todo maybe don't set the StrLen_or_Ind if null will be set below?
              if StrLen_or_Ind<>nil then
              begin
                SQLINTEGER(StrLen_or_Ind^):=tempsdw;
              end;
              */
            }
  
            //GlobalUtil.logError("SQLGetData read column "+rn+"  data: "+cursorBuf.length()+", null="+cursorNull);
  
            i++;
          } //while
          /*get row status*/
          sqlRowStatus=fStmt.fCon.marshalBuffer.getSQLUSMALLINT();  //again, only here to keep similar protocol as fetchScroll (& maybe future use)
          //log(format('SQLGetData read row status %d: %d',[rn,sqlRowStatus]),vDebug); //todo debug only - remove & assumes null terminated pCHAR! which it is from get routines...
          /*If there was an overall conversion error, then we set the setStatusExtra to it
           todo - check ok with standard!*/
          if (setStatusExtra==0) {
            setStatusExtra=sqlRowStatus;
          }
        } //for row
  
        resultCode=fStmt.fCon.marshalBuffer.getRETCODE();
        //todo we should set to SQL_SUCCESS_WITH_INFO if any rowStatus just had a problem - i.e a conversion problem
        // since server wouldn't have known...
        //todo remove result:=resultCode; //pass it on //todo fix first for DBX
        //GlobalUtil.logError("SQLGetData returns "+resultCode);
        //Translate result
        
        /*if error, then get error details: local-number, default-text*/
        int errCount=fStmt.fCon.marshalBuffer.getSQLINTEGER(); //error count
        if (resultCode==Global.SQL_ERROR) {
          for (int err=1;err<=errCount;err++) {
            resultErrCode=fStmt.fCon.marshalBuffer.getSQLINTEGER();
            resultErrText=fStmt.fCon.marshalBuffer.getpUCHAR_SWORD();
            GlobalUtil.logError("server error="+resultErrText);
          }
          //todo remove: never will happen: exit;
        }
        
        /**todo remove
        {If server returned SQL_SUCCESS, but we just encountered a conversion warning/error
         then modify the result code to SQL_SUCCESS_WITH_INFO as per ODBC spec.}
        if setStatusExtra<>0 then
          if resultCode=SQL_SUCCESS then
            resultCode:=SQL_SUCCESS_WITH_INFO;
  
        case resultCode of
          SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_NO_DATA:
          begin
            //state stays same
            //todo unless [x] [b] or [i] - see spec.
          end; {SQL_SUCCESS, SQL_SUCCESS_WITH_INFO}
          SQL_STILL_EXECUTING:
          begin
            s.state:=S11;
          end; {SQL_STILL_EXECUTING}
        else
          //todo what if SQL_ERROR?
          //(else) should never happen!? - it can if 1 row returned & it was an error row... //todo
        end; {case}
        */
  
      return true; 
    }
    else
    {
      return false; //out of range
    }
  }


  /**
   * In some cases, it is desirable to immediately release a
   * ResultSet's database and JDBC resources instead of waiting for
   * this to happen when it is automatically closed; the close
   * method provides this immediate release.
   *
   * <P><B>Note:</B> A ResultSet is automatically closed by the
   * Statement that generated it when that Statement is closed,
   * re-executed, or is used to retrieve the next result from a
   * sequence of multiple results. A ResultSet is also automatically
   * closed when it is garbage collected.  
   */
  public void close() throws java.sql.SQLException { 
    /*We must notify the server before we delete this object so it can delete its prepare/execute handle for it
     todo: note, maybe the server can auto-create a default handle so the majority of clients
           needn't notify it during this routine unless they allocate >1 stmt = unusual
    */
  
    /*Before we zap the server stmt, we unbind and close in case the caller hasn't done this,
     otherwise calling them during our stmt.free would try to notify the server about the unbinding/closing
     but by then it would be too late - the server handle would have been freed
    */
    
    //todo remove! HERE DEBUG ONLY
    /*
    if (true) {
      GlobalUtil.logError("resultSet close ignored for now: "+fStmt.lastSQL);   
      return; ////!!!!!!!!!!!!!!!!!
    }
    */
    
    if ((fStmt.fCon.state==Global.stateClosed) || (fStmt.ServerStatementHandle<=0)) {
      if (fStmt.fCon.state==Global.stateClosed) {
        GlobalUtil.logError("resultSet connection already closed!");
      }
      if (fStmt.ServerStatementHandle<=0) {
        GlobalUtil.logError("resultSet stmt already closed!");
      }
      //todo assert fStmt.ServerStatementHandle=-1
    }
    else
    {
      GlobalUtil.logError("resultSet closing...1: "+fStmt.lastSQL);
    
    /*todo here: remove: no binding at the moment...
      {Unbind all columns}
      with SQLConnection.Marshal do
      begin
        {Now auto-unbind all the columns}
        for i:=1 to colCount do
        begin
          ClearToSend;
          {Note: because we know these marshalled parameters all fit in a buffer together,
           and because the buffer is now empty after the clearToSend,
           we can omit the error result checking in the following put() calls = speed
          }
          //note: it might be easier just to pass serverStmt,recordNumber,bound(T or F)
          //but we're trying to keep this function the same on the server in case we need it for other things...
          // - we could always call a special serverBindCol routine here instead?
          putFunction(SQL_API_SQLSETDESCFIELD);
          putSQLHSTMT(ServerStatementHandle); //pass server statement ref (it has no concept of our desc's)
          putSQLSMALLINT(col[i].iFldType); //todo don't really need this since server only cares about us setting its ARD responsibilities (currently...)
          //together, the above two are the server's closest concept of our DescriptorHandle
          putSQLSMALLINT(col[i].iFldNum); //this will be the colRef(-1) on the server
          putSQLSMALLINT(SQL_DESC_DATA_POINTER); //=SQL_DESC_DATA_POINTER
          putSQLPOINTER(SQLPOINTER(0)); //= 0=unbound, else bound
          putSQLINTEGER(col[i].iUnits1{todo:better to set & use iLen?});
          //we send Value (& BufferLength) even though it means nothing to the server,
          // - the server just needs to know if it's 0 or not to be able to track the bind/unbinds
          // although it might help for debugging/error reporting/comparing colBound values? - not used for such yet...
          if Send<>ok then
          begin
            result:=SQL_ERROR2;
            logError(ss08S01);
            exit;
          end;
    
          {Wait for response}
          if Read<>ok then
          begin
            result:=SQL_ERROR2;
            logError(ssHYT00);
            exit;
          end;
          {Note: because we know these marshalled parameters all fit in a buffer together,
           and because the buffer has been read in total by the Read above because its size was known,
           we can omit the error result checking in the following get() calls = speed
          }
          getFunction(functionId);
          if functionId<>SQL_API_SQLSETDESCFIELD then
          begin
            result:=SQL_ERROR2;
            logError(ss08S01);
            exit;
          end;
          getRETCODE(resultCode);
          //todo remove result:=resultCode; //pass it on //todo fix first for DBX!
          {Translate result}
          case resultCode of
            SQL_ERROR: result:=SQL_ERROR2;
          else
            result:=SQL_SUCCESS; //DBX ignores warnings etc.
          end; {case}
          {$IFDEF DEBUG_LOG}
          log(format('close unbound column %d (%d) returns %d',[i,col[i].iFldNum,resultCode]),vLow);
          {$ENDIF}
          {if error, then get error details: local-number, default-text}
          if getSQLINTEGER(resultErrCode)<>ok then exit; //error count
          if resultCode=SQL_ERROR then
          begin
            for err:=1 to resultErrCode do
            begin
              if getSQLINTEGER(resultErrCode)<>ok then exit;
              if getpUCHAR_SWORD(pUCHAR(resultErrText),DYNAMIC_ALLOCATION,tempsw)<>ok then exit;
              case resultErrCode of
                seInvalidHandle:         result:=DBXERR_INVALIDHNDL;
                seNotPrepared:           result:=SQL_SUCCESS; //todo ok? result:=SQL_ERROR2;
                seColumnNotBound:        result:=SQL_SUCCESS; //todo ok? result:=SQL_ERROR2;
                seColumnAlreadyBound:    result:=SQL_SUCCESS; //todo ok? result:=SQL_ERROR2;
                seUnknownFieldId:        result:=SQL_SUCCESS; //todo ok? result:=SQL_ERROR2;
              else
                result:=SQL_ERROR2;
              end; {case}
              logError(resultErrText);
              if resultErrText<>nil then freeMem(resultErrText); //todo safe without length?
            end;
            exit;
          end;
        end; {for}
    
      end; {with}
    */
    
    //todo HERE call fStmt.Close! & move this code there
    //todo++: we call this code from fStmt!
    
    //(*todo resinstate HERE debug   
      /*call server SQLCloseCursor*/
      //todo do we need to if our cursor.state is not open!!!!??? save time e.g. when called from SQLendTran
      //todo Replace all AS with casts - speed
        fStmt.fCon.marshalBuffer.ClearToSend();
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer is now empty after the clearToSend,
         we can omit the error result checking in the following put() calls = speed
        */
        fStmt.fCon.marshalBuffer.putFunction(Global.SQL_API_SQLCLOSECURSOR);
        fStmt.fCon.marshalBuffer.putSQLHSTMT(fStmt.ServerStatementHandle); //pass server statement ref
        if (fStmt.prepared) {
          fStmt.fCon.marshalBuffer.putSQLSMALLINT((short)0); //keep server plan
        }
        else {
          fStmt.fCon.marshalBuffer.putSQLSMALLINT((short)1); //remove server plan
        }
        if (fStmt.fCon.marshalBuffer.Send()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        GlobalUtil.logError("resultSet closing...2 (prepared="+fStmt.prepared+")");
    
        /*Wait for response*/
        if (fStmt.fCon.marshalBuffer.Read()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer has been read in total by the Read above because its size was known,
         we can omit the error result checking in the following get() calls = speed
        */
        functionId=fStmt.fCon.marshalBuffer.getFunction();
        if (functionId!=Global.SQL_API_SQLCLOSECURSOR) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        resultCode=fStmt.fCon.marshalBuffer.getRETCODE();
        /*if error, then get error details: local-number, default-text*/
        int errCount=fStmt.fCon.marshalBuffer.getSQLINTEGER(); //error count
        if (resultCode==Global.SQL_ERROR) {
          for (int err=1;err<=errCount;err++) {
            resultErrCode=fStmt.fCon.marshalBuffer.getSQLINTEGER();
            resultErrText=fStmt.fCon.marshalBuffer.getpUCHAR_SWORD();
            GlobalUtil.logError("server error="+resultErrText);
          }
          //todo remove: never will happen: exit;
        }
    //*)
    
    /* moved to stmt!
      //todo split the close into resultset/stmt close?
      *Free the server handle*
        GlobalUtil.logError("resultSet closing...3");
        fStmt.fCon.marshalBuffer.ClearToSend();
        *Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer is now empty after the clearToSend,
         we can omit the error result checking in the following put() calls = speed
        *
        fStmt.fCon.marshalBuffer.putFunction(Global.SQL_API_SQLFREEHANDLE);
        fStmt.fCon.marshalBuffer.putSQLSMALLINT(Global.SQL_HANDLE_STMT);
        fStmt.fCon.marshalBuffer.putSQLHSTMT(fStmt.ServerStatementHandle); //pass server statement ref
        if (fStmt.fCon.marshalBuffer.Send()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
    
        *Wait for response*
        if (fStmt.fCon.marshalBuffer.Read()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        *Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer has been read in total by the Read above because its size was known,
         we can omit the error result checking in the following get() calls = speed
        *
        GlobalUtil.logError("resultSet closing...4");
        functionId=fStmt.fCon.marshalBuffer.getFunction();
        if (functionId!=Global.SQL_API_SQLFREEHANDLE) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        resultCode=fStmt.fCon.marshalBuffer.getRETCODE();
        *if error, then get error details: local-number, default-text*
        errCount=fStmt.fCon.marshalBuffer.getSQLINTEGER(); //error count
        if (resultCode==Global.SQL_ERROR) {
          for (int err=1;err<=errCount;err++) {
            resultErrCode=fStmt.fCon.marshalBuffer.getSQLINTEGER();
            resultErrText=fStmt.fCon.marshalBuffer.getpUCHAR_SWORD();
            GlobalUtil.logError("server error="+resultErrText);
          }
          //todo remove: never will happen: exit;
        }
     */ 
    
      /*Free any parameter buffers*/
      /* No need in Java
      for i:=1 to self.paramCount{todo for all array?} do
      begin
        if self.param[i].buffer<>nil then
        begin
          freeMem(self.param[i].buffer);
          self.param[i].bufferLen:=0;
        end;
      end;
      */
      GlobalUtil.logError("resultSet closed");
    
      //todo keep stmt! fStmt.ServerStatementHandle=-1; //reset our handle 
    }
  }

  /**
   * A column may have the value of SQL NULL; wasNull reports whether
   * the last column read had this special value.
   * Note that you must first call getXXX on a column to try to read
   * its value and then call wasNull() to find if the value was
   * the SQL NULL.
   *
   * @return true if last column read was SQL NULL
   */
  public boolean wasNull() throws java.sql.SQLException {
    return (cursorNull==Global.SQL_TRUE);
  }
    
  //======================================================================
  // Methods for accessing results by column index
  //======================================================================

  private int cursorBufToInt() throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    if (cursorBuf.length>=Global.sizeof_int) {
      int i=0;
      for (int siz=Global.sizeof_int-1; siz>=0; siz--) {
        i<<=Global.sizeof_byte;
        int b=(int)cursorBuf[siz];
        if (b<0) {b=(int)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        i = (int)(i | b); //i.e. reverse order
      }          
      return i;
    }
    else
    {
      throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);     
    }
  } 
  private long cursorBufToLong() throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    if (cursorBuf.length>=Global.sizeof_long) {
      long i=0;
      for (int siz=Global.sizeof_long-1; siz>=0; siz--) {
        i<<=Global.sizeof_byte;
        long b=(long)cursorBuf[siz];
        if (b<0) {b=(long)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        i = (long)(i | b); //i.e. reverse order
      }          
      return i;
    }
    else
    {
      throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);     
    }
  }
  /* not used
  private short cursorBufToShort() throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    if (cursorBuf.length>=Global.sizeof_int) {
      short usi=0;
      for (int siz=Global.sizeof_short-1; siz>=0; siz--) {
        usi<<=Global.sizeof_byte;
        short b=(short)cursorBuf[siz];
        if (b<0) {b=(short)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        usi = (short)(usi | b); //i.e. reverse order      
      }          
      return usi;
    }
    else
    {
      throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);     
    }
  }
  */
  //not used?
  private float cursorBufToFloat() throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    if (cursorBuf.length>=Global.sizeof_float) {
      int i=0;
      for (int siz=Global.sizeof_float-1; siz>=0; siz--) {
        i<<=Global.sizeof_byte;
        int b=(int)cursorBuf[siz];
        if (b<0) {b=(int)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        i = (int)(i | b); //i.e. reverse order
      }          
      return Float.intBitsToFloat(i); //todo ok>?
    }
    else
    {
      throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);     
    }
  }
  private double cursorBufToDouble() throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    //GlobalUtil.logError("cursorBufToDouble called "+cursorBuf[0]+' '+cursorBuf[1]+' '+cursorBuf[2]+' '+cursorBuf[3]+' '+cursorBuf[4]+' '+cursorBuf[5]+' '+cursorBuf[6]+' '+cursorBuf[7]);
    if (cursorBuf.length>=Global.sizeof_double) {
      long il=0;
      for (int siz=Global.sizeof_double-1; siz>=0; siz--) {
        il<<=Global.sizeof_byte;
        long b=(long)cursorBuf[siz];
        if (b<0) {b=(long)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        il = (long)(il | b); //i.e. reverse order
      }          
      //GlobalUtil.logError("cursorBufToDouble called "+Long.toBinaryString(il));
      return Double.longBitsToDouble(il); //todo ok>?
    }
    else
    {
      throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);     
    }
  } 
  private Date cursorBufToDate() throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    //GlobalUtil.logError("cursorBufToDate called "+cursorBuf[0]+' '+cursorBuf[1]+' '+cursorBuf[2]+' '+cursorBuf[3]);
    if (cursorBuf.length>=Global.sizeof_date) {
      short offset=0;
      short sy=0;
      for (int siz=offset+(Global.sizeof_dateY-1); siz>=offset; siz--) {
        sy<<=Global.sizeof_byte;
        short b=(short)cursorBuf[siz];
        if (b<0) {b=(short)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        sy = (short)(sy | b); //i.e. reverse order
      }          
      offset=(short)(offset+Global.sizeof_dateY);
      short sm=0;
      for (int siz=offset+(Global.sizeof_dateM-1); siz>=offset; siz--) {
        sm<<=Global.sizeof_byte;
        short b=(short)cursorBuf[siz];
        if (b<0) {b=(short)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        sm = (short)(sm | b); //i.e. reverse order
      }          
      offset=(short)(offset+Global.sizeof_dateM);
      short sd=0;
      for (int siz=offset+(Global.sizeof_dateD-1); siz>=offset; siz--) {
        sd<<=Global.sizeof_byte;
        short b=(short)cursorBuf[siz];
        if (b<0) {b=(short)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        sd = (short)(sd | b); //i.e. reverse order
      }          
      offset=(short)(offset+Global.sizeof_dateD);
      //GlobalUtil.logError("y m d "+sy+" "+sm+" "+sd);
      //GlobalUtil.logError("cursorBufToDouble called "+Long.toBinaryString(il));
      return new Date(sy-1900,sm-1,sd); //todo ok? deprecated!
    }
    else
    {
      throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);     
    }
  }
  private Time cursorBufToTime(short baseOffset) throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    //GlobalUtil.logError("cursorBufToTime called "+cursorBuf[0]+' '+cursorBuf[1]+' '+cursorBuf[2]+' '+cursorBuf[3]+' '+cursorBuf[4]+' '+cursorBuf[5]+' '+cursorBuf[6]+' '+cursorBuf[7]+' '+cursorBuf[8]+' '+cursorBuf[9]);
    if (cursorBuf.length>=Global.sizeof_time) {
      short offset=baseOffset;
      short sh=0;
      for (int siz=offset+(Global.sizeof_timeH-1); siz>=offset; siz--) {
        sh<<=Global.sizeof_byte;
        short b=(short)cursorBuf[siz];
        if (b<0) {b=(short)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        sh = (short)(sh | b); //i.e. reverse order
      }          
      offset=(short)(offset+Global.sizeof_timeH);
      short sm=0;
      for (int siz=offset+(Global.sizeof_timeM-1); siz>=offset; siz--) {
        sm<<=Global.sizeof_byte;
        short b=(short)cursorBuf[siz];
        if (b<0) {b=(short)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        sm = (short)(sm | b); //i.e. reverse order
      }          
      offset=(short)(offset+Global.sizeof_timeM);
      //GlobalUtil.logError("s from "+offset+" for "+Global.sizeof_timeS);
      
      offset=(short)(offset+2); //todo remove: debug?
      
      int ss=0;
      for (int siz=offset+(Global.sizeof_timeS-1); siz>=offset; siz--) {
        ss<<=Global.sizeof_byte;
        int b=(int)cursorBuf[siz];
        if (b<0) {b=(int)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        ss = (int)(ss | b); //i.e. reverse order
      }          
      offset=(short)(offset+Global.sizeof_timeS);
      short sc=0;
      for (int siz=offset+(Global.sizeof_timeSc-1); siz>=offset; siz--) {
        sc<<=Global.sizeof_byte;
        short b=(short)cursorBuf[siz];
        if (b<0) {b=(short)(b+256);} //when we cast the byte to short, any sign bit will have been stretched to the far left & lost its value
        sc = (short)(sc | b); //i.e. reverse order
      }          
      offset=(short)(offset+Global.sizeof_timeSc);
      //Denormalise seconds
      ss=(int)(ss/Math.pow(10,Global.TIME_MAX_SCALE)); //i.e. shift TIME_MAX_SCALE decimal places to the right
      //todo Adjust the scale?

      //GlobalUtil.logError("h m s "+sh+" "+sm+" "+ss);
      return new Time(sh,sm,ss); //todo ok? deprecated!
    }
    else
    {
      throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);     
    }
  }
  private Timestamp cursorBufToTimestamp() throws java.sql.SQLException {
    //todo use this in marshalBuffer routines!
    //GlobalUtil.logError("cursorBufToTime called "+cursorBuf[0]+' '+cursorBuf[1]+' '+cursorBuf[2]+' '+cursorBuf[3]+' '+cursorBuf[4]+' '+cursorBuf[5]+' '+cursorBuf[6]+' '+cursorBuf[7]+' '+cursorBuf[8]+' '+cursorBuf[9]);
    return new Timestamp(cursorBufToDate().getTime()+cursorBufToTime(Global.sizeof_date).getTime());    
  }

  /**
   * Get the value of a column in the current row as a Java String.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public String getString(int columnIndex) throws java.sql.SQLException {
    //GlobalUtil.logError("getString called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return null;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return new String(Integer.toString(cursorBufToInt())); //break
              
              case Global.SQL_FLOAT: return new String(Double.toString(cursorBufToDouble())); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return new String(Double.toString((cursorBufToLong()/Math.pow(10,(double)fStmt.col[columnIndex-1].iUnits2)))); //break
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: if ((cursorBuf.length==1) && (cursorBuf[0]==0)) {return "";} else {return new String(cursorBuf);}  //break
              
              case Global.SQL_TYPE_DATE: return new String(cursorBufToDate().toString()); //break 
              case Global.SQL_TYPE_TIME: return new String(cursorBufToTime((short)0).toString());  //break
              case Global.SQL_TYPE_TIMESTAMP: return new String(cursorBufToTimestamp().toString()); //break
              
              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      /*finally
        if cursorBuf<>nil then
        begin
          freeMem(cursorBuf); //todo safe without length?
          cursorBuf:=nil;
        end;
      end; {try}
      */
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a Java boolean.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is false
   */
  public boolean getBoolean(int columnIndex) throws java.sql.SQLException {
    return false;
  }

  /**
   * Get the value of a column in the current row as a Java byte.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public byte getByte(int columnIndex) throws java.sql.SQLException {
    return 0;
  }

  /**
   * Get the value of a column in the current row as a Java short.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public short getShort(int columnIndex) throws java.sql.SQLException {    
    //GlobalUtil.logError("getInt called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return 0;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return (short)cursorBufToInt(); //break
              
              case Global.SQL_FLOAT: return (short)cursorBufToDouble(); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return (short)(cursorBufToLong()/Math.pow(10,(double)fStmt.col[columnIndex-1].iUnits2)); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Short.parseShort(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a Java int.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public int getInt(int columnIndex) throws java.sql.SQLException {
    //GlobalUtil.logError("getInt called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return 0;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return cursorBufToInt(); //break
              
              case Global.SQL_FLOAT: return (int)cursorBufToDouble(); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return (int)(cursorBufToLong()/Math.pow(10,(double)fStmt.col[columnIndex-1].iUnits2)); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Integer.parseInt(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a Java long.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public long getLong(int columnIndex) throws java.sql.SQLException {
    //GlobalUtil.logError("getLong called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return 0;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return (long)cursorBufToInt(); //break
              
              case Global.SQL_FLOAT: return (long)cursorBufToDouble(); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return (long)(cursorBufToLong()/Math.pow(10,(double)fStmt.col[columnIndex-1].iUnits2)); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Long.parseLong(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a Java float.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public float getFloat(int columnIndex) throws java.sql.SQLException {
    //GlobalUtil.logError("getInt called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return 0;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return (float)cursorBufToInt(); //break
              
              case Global.SQL_FLOAT: return (float)cursorBufToDouble(); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return (float)(cursorBufToLong()/Math.pow(10,(double)fStmt.col[columnIndex-1].iUnits2)); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Float.parseFloat(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a Java double.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public double getDouble(int columnIndex) throws java.sql.SQLException {
    //GlobalUtil.logError("getInt called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return 0;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return (double)cursorBufToInt(); //break
              
              case Global.SQL_FLOAT: return (double)cursorBufToDouble(); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return (double)(cursorBufToLong()/Math.pow(10,(double)fStmt.col[columnIndex-1].iUnits2)); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Double.parseDouble(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a java.lang.BigDecimal object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param scale the number of digits to the right of the decimal
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public BigDecimal getBigDecimal(int columnIndex, int scale)
  throws java.sql.SQLException {
    //deprecated
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return BigDecimal.valueOf(0,0);
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return new BigDecimal((double)cursorBufToInt()); //break
              
              case Global.SQL_FLOAT: return new BigDecimal((double)cursorBufToDouble()); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return BigDecimal.valueOf(cursorBufToLong(),scale /*fStmt.col[columnIndex-1].iUnits2*/); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return new BigDecimal(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  public BigDecimal getBigDecimal(int columnIndex)
  throws java.sql.SQLException {
    //GlobalUtil.logError("getInt called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return BigDecimal.valueOf(0,0);
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: return new BigDecimal((double)cursorBufToInt()); //break
              
              case Global.SQL_FLOAT: return new BigDecimal((double)cursorBufToDouble()); //break
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: return BigDecimal.valueOf(cursorBufToLong(),fStmt.col[columnIndex-1].iUnits2); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return new BigDecimal(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a Java byte array.
   * The bytes represent the raw values returned by the driver.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public byte[] getBytes(int columnIndex) throws java.sql.SQLException {
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return null;
          }
          else
          {
            return cursorBuf;
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a java.sql.Date object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public java.sql.Date getDate(int columnIndex) throws java.sql.SQLException {
    //GlobalUtil.logError("getDate called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return null;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo ok?!    
              
              case Global.SQL_FLOAT: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo ok?!
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo ok?!
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Date.valueOf(temp);} // break;
              
              case Global.SQL_TYPE_DATE: return cursorBufToDate(); //break
              case Global.SQL_TYPE_TIME: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIMESTAMP: return new Date(cursorBufToTimestamp().getDate()); //break
              
              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a java.sql.Time object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public java.sql.Time getTime(int columnIndex) throws java.sql.SQLException {
    //GlobalUtil.logError("getTime called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return null;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              
              case Global.SQL_FLOAT: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Time.valueOf(temp);} // break;
              
              case Global.SQL_TYPE_DATE: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              case Global.SQL_TYPE_TIME: return cursorBufToTime((short)0); //break
              case Global.SQL_TYPE_TIMESTAMP: return new Time(cursorBufToTimestamp().getTime()); //break

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * Get the value of a column in the current row as a java.sql.Timestamp object.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public java.sql.Timestamp getTimestamp(int columnIndex)
  throws java.sql.SQLException {
    //GlobalUtil.logError("getTime called "+columnIndex);
  
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return null;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: 
              case Global.SQL_SMALLINT: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              
              case Global.SQL_FLOAT: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion);
              
              case Global.SQL_NUMERIC:
              case Global.SQL_DECIMAL: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); 
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR:
              case Global.SQL_LONGVARCHAR:
              case Global.SQL_LONGVARBINARY: {String temp=new String(cursorBuf); return Timestamp.valueOf(temp);} // break;
              
              case Global.SQL_TYPE_DATE: return new Timestamp(cursorBufToDate().getDate()); //break
              case Global.SQL_TYPE_TIME: return new Timestamp(cursorBufToTime((short)0).getTime()); //break
              case Global.SQL_TYPE_TIMESTAMP: return cursorBufToTimestamp(); //break

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * A column value can be retrieved as a stream of ASCII characters 
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into ASCII.
   *
   * <P><B>Note:</B> All the data in the returned stream must be
   * read prior to getting the value of any other column. The next
   * call to a get method implicitly closes the stream. . Also, a
   * stream may return 0 for available() whether there is data
   * available or not.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a Java input stream that delivers the database column value
   * as a stream of one byte ASCII characters.  If the value is SQL NULL
   * then the result is null.  
   */
  public java.io.InputStream getAsciiStream(int columnIndex)
  throws java.sql.SQLException {
    return null;
  }

  /**
   * A column value can be retrieved as a stream of Unicode characters 
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into Unicode.
   *
   * <P><B>Note:</B> All the data in the returned stream must be
   * read prior to getting the value of any other column. The next
   * call to a get method implicitly closes the stream. . Also, a
   * stream may return 0 for available() whether there is data
   * available or not.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a Java input stream that delivers the database column value
   * as a stream of two byte Unicode characters.  If the value is SQL NULL
   * then the result is null.  
   */
  public java.io.InputStream getUnicodeStream(int columnIndex) 
  throws java.sql.SQLException {
    return null;
  }
  

  /**
   * A column value can be retrieved as a stream of uninterpreted bytes 
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARBINARY values.
   *
   * <P><B>Note:</B> All the data in the returned stream must be
   * read prior to getting the value of any other column. The next
   * call to a get method implicitly closes the stream. Also, a
   * stream may return 0 for available() whether there is data
   * available or not.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a Java input stream that delivers the database column value
   * as a stream of uninterpreted bytes.  If the value is SQL NULL
   * then the result is null.  
   */
  public java.io.InputStream getBinaryStream(int columnIndex)
  throws java.sql.SQLException {
    return null;
  }


  //======================================================================
  // Methods for accessing results by column name
  //======================================================================

  //Note: returns -1 if not found, else the column number (starting at 1)
  public int findColNumber(String s) {
    for (int i=0; i<fStmt.colCount; i++) {
      //System.out.println("searching..."+fStmt.col[i].colName);
      if (fStmt.col[i].colName.equalsIgnoreCase(s)) {return i+1;} //success
    }
    return -1; //fail
  }

  /**
   * Get the value of a column in the current row as a Java String.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public String getString(String columnName) throws java.sql.SQLException {   
    return getString(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a Java boolean.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is false
   */
  public boolean getBoolean(String columnName) throws java.sql.SQLException {
    return false;
  }

  /**
   * Get the value of a column in the current row as a Java byte.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public byte getByte(String columnName) throws java.sql.SQLException {
    return 0;
  }

  /**
   * Get the value of a column in the current row as a Java short.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public short getShort(String columnName) throws java.sql.SQLException {
    return getShort(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a Java int.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public int getInt(String columnName) throws java.sql.SQLException {
    return getInt(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a Java long.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public long getLong(String columnName) throws java.sql.SQLException {
    return getLong(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a Java float.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public float getFloat(String columnName) throws java.sql.SQLException {
    return getFloat(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a Java double.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is 0
   */
  public double getDouble(String columnName) throws java.sql.SQLException {
    return getDouble(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a java.lang.BigDecimal object.
   *
   * @param columnName is the SQL name of the column
   * @param scale the number of digits to the right of the decimal
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public BigDecimal getBigDecimal(String columnName, int scale)
  throws java.sql.SQLException {
    return getBigDecimal(findColNumber(columnName),scale);
  }

  public BigDecimal getBigDecimal(String columnName)
  throws java.sql.SQLException {
    return getBigDecimal(findColNumber(columnName));
  }
  /**
   * Get the value of a column in the current row as a Java byte array.
   * The bytes represent the raw values returned by the driver.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public byte[] getBytes(String columnName) throws java.sql.SQLException {
    return getBytes(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a java.sql.Date object.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public java.sql.Date getDate(String columnName) throws java.sql.SQLException {
    return getDate(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a java.sql.Time object.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public java.sql.Time getTime(String columnName) throws java.sql.SQLException {
    return getTime(findColNumber(columnName));
  }

  /**
   * Get the value of a column in the current row as a java.sql.Timestamp object.
   *
   * @param columnName is the SQL name of the column
   * @return the column value; if the value is SQL NULL, the result is null
   */
  public java.sql.Timestamp getTimestamp(String columnName)
  throws java.sql.SQLException {
    return getTimestamp(findColNumber(columnName));
  }

  /**
   * A column value can be retrieved as a stream of ASCII characters 
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into ASCII.
   *
   * <P><B>Note:</B> All the data in the returned stream must
   * be read prior to getting the value of any other column. The
   * next call to a get method implicitly closes the stream.
   *
   * @param columnName is the SQL name of the column
   * @return a Java input stream that delivers the database column value
   * as a stream of one byte ASCII characters.  If the value is SQL NULL
   * then the result is null.
   */
  public java.io.InputStream getAsciiStream(String columnName)
  throws java.sql.SQLException {
    return null;
  }

  /**
   * A column value can be retrieved as a stream of Unicode characters 
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
   * do any necessary conversion from the database format into Unicode.
   *
   * <P><B>Note:</B> All the data in the returned stream must
   * be read prior to getting the value of any other column. The
   * next call to a get method implicitly closes the stream.
   *
   * @param columnName is the SQL name of the column
   * @return a Java input stream that delivers the database column value
   * as a stream of two byte Unicode characters.  If the value is SQL NULL
   * then the result is null.
   */
  public java.io.InputStream getUnicodeStream(String columnName)
  throws java.sql.SQLException {
    return null;
  }

  /**
   * A column value can be retrieved as a stream of uninterpreted bytes 
   * and then read in chunks from the stream.  This method is particularly
   * suitable for retrieving large LONGVARBINARY values.
   *
   * <P><B>Note:</B> All the data in the returned stream must
   * be read prior to getting the value of any other column. The
   * next call to a get method implicitly closes the stream.
   *
   * @param columnName is the SQL name of the column
   * @return a Java input stream that delivers the database column value
   * as a stream of uninterpreted bytes.  If the value is SQL NULL
   * then the result is null.
   */
  public java.io.InputStream getBinaryStream(String columnName)
  throws java.sql.SQLException {
    return null;
  }


  //=====================================================================
  // Advanced features:
  //=====================================================================

  /**
   * <p>The first warning reported by calls on this ResultSet is
   * returned. Subsequent ResultSet warnings will be chained to this
   * SQLWarning.
   *
   * <P>The warning chain is automatically cleared each time a new
   * row is read.
   *
   * <P><B>Note:</B> This warning chain only covers warnings caused
   * by ResultSet methods.  Any warning caused by statement methods
   * (such as reading OUT parameters) will be chained on the
   * Statement object. 
   *
   * @return the first SQLWarning or null 
   */
  public SQLWarning getWarnings() throws java.sql.SQLException {
    return null;
  }

  /**
   * After this call getWarnings returns null until a new warning is
   * reported for this ResultSet.  
   */
  public void clearWarnings() throws java.sql.SQLException {
  }

  /**
   * Get the name of the SQL cursor used by this ResultSet.
   *
   * <P>In SQL, a result table is retrieved through a cursor that is
   * named. The current row of a result can be updated or deleted
   * using a positioned update/delete statement that references the
   * cursor name. 
   * 
   * <P>JDBC supports this SQL feature by providing the name of the
   * SQL cursor used by a ResultSet. The current row of a ResultSet
   * is also the current row of this SQL cursor.
   *
   * <P><B>Note:</B> If positioned update is not supported a
   * java.sql.SQLException is thrown
   *
   * @return the ResultSet's SQL cursor name
   */
  public String getCursorName() throws java.sql.SQLException {
    return null;
  }

  /**
   * The number, types and properties of a ResultSet's columns
   * are provided by the getMetaData method.
   *
   * @return the description of a ResultSet's columns
   */
  public ResultSetMetaData getMetaData() throws java.sql.SQLException {
    return new ResultSetMetaDataSQL(this);
  }

  /**
   * <p>Get the value of a column in the current row as a Java object.
   *
   * <p>This method will return the value of the given column as a
   * Java object.  The type of the Java object will be the default
   * Java Object type corresponding to the column's SQL type,
   * following the mapping specified in the JDBC spec.
   *
   * <p>This method may also be used to read datatabase specific abstract
   * data types.
   *
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return A java.lang.Object holding the column value.  
   */
  public Object getObject(int columnIndex) throws java.sql.SQLException {
    if (columnIndex<=fStmt.colCount) {
      if (readRaw(columnIndex)) {
      //try
          if (wasNull()) {
            return null;
          }
          else
          {
            switch (fStmt.col[columnIndex-1].iFldType) {
              case Global.SQL_INTEGER: return new Integer(Integer.toString(cursorBufToInt())); //break
              case Global.SQL_SMALLINT: return new Short(Integer.toString(cursorBufToInt())); //break
              
              case Global.SQL_FLOAT: return new Double(Double.toString(cursorBufToDouble())); //break
              
              case Global.SQL_NUMERIC: 
              case Global.SQL_DECIMAL: return new BigDecimal(Double.toString((cursorBufToLong()/Math.pow(10,(double)fStmt.col[columnIndex-1].iUnits2)))); //break;
              
              case Global.SQL_CHAR:
              case Global.SQL_VARCHAR: if ((cursorBuf.length==1) && (cursorBuf[0]==0)) {return "";} else {return new String(cursorBuf);}  //break
              
              case Global.SQL_TYPE_DATE: return new Date(cursorBufToDate().getDate()); //break
              case Global.SQL_TYPE_TIME: return new Time(cursorBufToTime((short)0).getTime()); //break
              case Global.SQL_TYPE_TIMESTAMP: return new Timestamp(cursorBufToTimestamp().getYear(),cursorBufToTimestamp().getMonth(),cursorBufToTimestamp().getDate(),cursorBufToTimestamp().getHours(),cursorBufToTimestamp().getMinutes(),cursorBufToTimestamp().getSeconds(),0); //break
                           
              //todo return java.sql.Clob and Blob for these:
              case Global.SQL_LONGVARCHAR: if ((cursorBuf.length==1) && (cursorBuf[0]==0)) {return "";} else {return new String(cursorBuf);}  //break
              case Global.SQL_LONGVARBINARY: if ((cursorBuf.length==1) && (cursorBuf[0]==0)) {return "";} else {return new String(cursorBuf);}  //break             

              default: throw new SQLException (Global.seInvalidConversionText,Global.ssNA,Global.seInvalidConversion); //todo assertion!    
            }
          }
      /*finally
        if cursorBuf<>nil then
        begin
          freeMem(cursorBuf); //todo safe without length?
          cursorBuf:=nil;
        end;
      end; {try}
      */
      }
      else
      {  //todo actually a more general error...
        throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
      }
    }
    else
    {
      throw new SQLException (Global.seInvalidColumnIndexText,Global.ssNA,Global.seInvalidColumnIndex);     
    }
  }

  /**
   * <p>Get the value of a column in the current row as a Java object.
   *
   * <p>This method will return the value of the given column as a
   * Java object.  The type of the Java object will be the default
   * Java Object type corresponding to the column's SQL type,
   * following the mapping specified in the JDBC spec.
   *
   * <p>This method may also be used to read datatabase specific abstract
   * data types.
   *
   * @param columnName is the SQL name of the column
   * @return A java.lang.Object holding the column value.  
   */
  public Object getObject(String columnName) throws java.sql.SQLException {
    return getObject(findColNumber(columnName));
  }

  //----------------------------------------------------------------

  /**
   * Map a Resultset column name to a ResultSet column index.
   *
   * @param columnName the name of the column
   * @return the column index
   */
  public int findColumn(String columnName) throws java.sql.SQLException {
    return findColNumber(columnName);
  }
  
  
  public Reader getCharacterStream(int columnIndex) throws SQLException {
    return null;
  }

  public Reader getCharacterStream(String columnName) throws SQLException {
    return null;
  }

  public boolean isBeforeFirst() throws SQLException {
    return false;
  }

  public boolean isAfterLast() throws SQLException {
    return false;
  }

  public boolean isFirst() throws SQLException {
    return false;
  }

  public boolean isLast() throws SQLException {
    return false;
  }

  public void beforeFirst() throws SQLException {
  }

  public void afterLast() throws SQLException {
  }

  public boolean first() throws SQLException {
    return false;
  }

  public boolean last() throws SQLException {
    return false;
  }

  public boolean absolute(int row) throws SQLException {
    return false;
  }

  public boolean relative(int rows) throws SQLException {
    return false;
  }

  public boolean previous() throws SQLException {
    return false;
  }

  public void setFetchDirection(int direction) throws SQLException {
  }

  public int getFetchDirection() throws SQLException {
    return FETCH_FORWARD;
  }

  public void setFetchSize(int rows) throws SQLException {
  }

  public int getFetchSize() throws SQLException {
    return 1; //todo allow increase & set
  }

  public int getType() throws SQLException {
    return TYPE_FORWARD_ONLY;
  }

  public int getConcurrency() throws SQLException {
    return CONCUR_READ_ONLY;
  }

  public boolean rowUpdated() throws SQLException {
    return false;
  }

  public boolean rowInserted() throws SQLException {
    return false;
  }

  public boolean rowDeleted() throws SQLException {
    return false;
  }

  public void updateNull(int columnIndex) throws SQLException {
  }

  public void updateBoolean(int columnIndex, boolean x) throws SQLException {
  }

  public void updateByte(int columnIndex, byte x) throws SQLException {
  }

  public void updateShort(int columnIndex, short x) throws SQLException {
  }

  public void updateInt(int columnIndex, int x) throws SQLException {
  }

  public void updateLong(int columnIndex, long x) throws SQLException {
  }

  public void updateFloat(int columnIndex, float x) throws SQLException {
  }

  public void updateDouble(int columnIndex, double x) throws SQLException {
  }

  public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
  }

  public void updateString(int columnIndex, String x) throws SQLException {
  }

  public void updateBytes(int columnIndex, byte[] x) throws SQLException {
  }

  public void updateDate(int columnIndex, Date x) throws SQLException {
  }

  public void updateTime(int columnIndex, Time x) throws SQLException {
  }

  public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
  }

  public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
  }

  public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
  }

  public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
  }

  public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
  }

  public void updateObject(int columnIndex, Object x) throws SQLException {
  }


  public void updateNull(String columnName) throws SQLException {
  }

  public void updateBoolean(String columnName, boolean x) throws SQLException {
  }

  public void updateByte(String columnName, byte x) throws SQLException {
  }

  public void updateShort(String columnName, short x) throws SQLException {
  }

  public void updateInt(String columnName, int x) throws SQLException {
  }

  public void updateLong(String columnName, long x) throws SQLException {
  }

  public void updateFloat(String columnName, float x) throws SQLException {
  }

  public void updateDouble(String columnName, double x) throws SQLException {
  }

  public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
  }

  public void updateString(String columnName, String x) throws SQLException {
  }

  public void updateBytes(String columnName, byte[] x) throws SQLException {
  }

  public void updateDate(String columnName, Date x) throws SQLException {
  }

  public void updateTime(String columnName, Time x) throws SQLException {
  }

  public void updateTimestamp(String columnName, Timestamp x) throws SQLException {
  }

  public void updateAsciiStream(String columnName, InputStream x, int length) throws SQLException {
  }

  public void updateBinaryStream(String columnName, InputStream x, int length) throws SQLException {
  }

  public void updateCharacterStream(String columnName, Reader x, int length) throws SQLException {
  }

  public void updateObject(String columnName, Object x, int scale) throws SQLException {
  }

  public void updateObject(String columnName, Object x) throws SQLException {
  }


  public int getRow() throws SQLException {
    return -1;
  }

  public void insertRow() throws SQLException {
  }
  public void updateRow() throws SQLException {
  }
  public void deleteRow() throws SQLException {
  }
  public void refreshRow() throws SQLException {
  }
  public void cancelRowUpdates() throws SQLException {
  }

  public void moveToInsertRow() throws SQLException {
  }

  public void moveToCurrentRow() throws SQLException {
  }

  public Statement getStatement() throws SQLException {
    return fStmt;
  }

  public Object getObject(int i,
                        java.util.Map map) throws SQLException {
    return null;
  }                      

  public Ref getRef(int i) throws SQLException {
    return null;
  }

  public Blob getBlob(int i) throws SQLException {
    return null;
  }
 
  public Clob getClob(int i) throws SQLException {
    return null;
  }

  public Array getArray(int i) throws SQLException {
    return null;
  }  

  public Object getObject(String colName,
                        java.util.Map map) throws SQLException {
    return null;
  }                     

  public Ref getRef(String colName) throws SQLException {
    return null;
  }

  public Blob getBlob(String colName) throws SQLException {
    return null;
  }

  public Clob getClob(String colName) throws SQLException {
    return null;
  }

  public Array getArray(String colName) throws SQLException {
    return null;
  }

  public Date getDate(int columnIndex,
                    java.util.Calendar cal) throws SQLException {
    return null;
  }
  
  public Date getDate(String columnName,
                    java.util.Calendar cal) throws SQLException {
    return null;
  }
  
  public Time getTime(int columnIndex,
                    java.util.Calendar cal) throws SQLException {
    return null;
  }
  
  public Time getTime(String columnName,
                    java.util.Calendar cal) throws SQLException {
    return null;
  }
  
  public Timestamp getTimestamp(int columnIndex,
                              java.util.Calendar cal) throws SQLException {
    return null;
  }
                     
  public Timestamp getTimestamp(String columnName,
                              java.util.Calendar cal) throws SQLException {
    return null;
  }
  

};

