package uk.co.thinksql;

/*       ThinkSQL Relational Database Management System
              Copyright Â© 2000-2012  Greg Gaughan
                  See LICENCE.txt for details
*/

import java.sql.*;

import uk.co.thinksql.Global.*;
import uk.co.thinksql.ConnectionSQL.*;
import uk.co.thinksql.ResultSetSQL.*;

/**
 * <P>A Statement object is used for executing a static SQL statement
 * and obtaining the results produced by it. 
 *
 * <P>Only one ResultSet per Statement can be open at any point in
 * time. Therefore, if the reading of one ResultSet is interleaved
 * with the reading of another, each must have been generated by
 * different Statements. All statement execute methods implicitly
 * close a statment's current ResultSet if an open one exists.
 *
 * @see Connection#createStatement
 * @see ResultSet 
 */
public class StatementSQL implements java.sql.Statement {
  
  public ConnectionSQL fCon;
  
  public int ServerStatementHandle=0;
  public int colCount;
  public ColumnSQL[] col; //columns for resultSet //todo maybe move down into resultSet? //Note: offset 0, but 1 in Delphi
  protected int paramCount;
  public ParamSQL[] param; //Note: offset 0, but 1 in Delphi
  
  protected boolean resultSet;
  protected ResultSet fResultSet; 
  public boolean prepared;   //for tracking state  (used by preparedStatement resultSet)
  private int affectedRowCount;
  
  public String lastSQL; //todo remove: temp


  //todo create these when needed inside the methods... better scoping
  private short functionId;
  private short resultCode;
  private int resultErrCode;
  private String resultErrText;

  public StatementSQL(ConnectionSQL con) throws SQLException {
    int serverS;

    fCon=con;     
    col=new ColumnSQL[Global.MAX_COL_PER_TABLE];
    for (int i=0; i<col.length; i++) {col[i]=new ColumnSQL();}
    param=new ParamSQL[Global.MAX_PARAM_PER_QUERY];
    for (int i=0; i<param.length; i++) {param[i]=new ParamSQL();}
    
    //HERE!!!
    ServerStatementHandle=-1; //=> not connected
    prepared=false; //new in JDBC: todo fix in dbExpress?
  
    /*We notify the server of this new command(=stmt)*/
      fCon.marshalBuffer.ClearToSend();
      /*Note: because we know these marshalled parameters all fit in a buffer together,
       and because the buffer is now empty after the clearToSend,
       we can omit the error result checking in the following put() calls = speed
      */
      fCon.marshalBuffer.putFunction(Global.SQL_API_SQLALLOCHANDLE);
      fCon.marshalBuffer.putSQLSMALLINT(Global.SQL_HANDLE_STMT);
      fCon.marshalBuffer.putSQLHDBC(0/*SQLHDBC(fCon)*/);  //todo assert this = c? also elsewhere?
      if (fCon.marshalBuffer.Send()!=Global.ok) {
        throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
      }
  
      /*Wait for response*/
      if (fCon.marshalBuffer.Read()!=Global.ok) {
        throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
      }
      /*Note: because we know these marshalled parameters all fit in a buffer together,
       and because the buffer has been read in total by the Read above because its size was known,
       we can omit the error result checking in the following get() calls = speed
      */
      functionId=fCon.marshalBuffer.getFunction();
      if (functionId!=Global.SQL_API_SQLALLOCHANDLE) {
        GlobalUtil.logError("StatementSQL Failed functionId="+functionId);
        throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
      }
      serverS=fCon.marshalBuffer.getSQLHSTMT();  //server will return 0 if failed
      resultCode=fCon.marshalBuffer.getRETCODE();
      //result:=resultCode; //pass it on //todo fix for DBX first!!!!!
      GlobalUtil.logError("SQLAllocHandle returns "+resultCode+" "+serverS);

      /*if error, then get error details: local-number, default-text*/
      int errCount=fCon.marshalBuffer.getSQLINTEGER(); //error count
      if (resultCode==Global.SQL_ERROR) {
        for (int err=1;err<=errCount;err++) {
          resultErrCode=fCon.marshalBuffer.getSQLINTEGER();
          resultErrText=fCon.marshalBuffer.getpUCHAR_SWORD();
          GlobalUtil.logError("server error="+resultErrText);
        }
        //todo remove: never will happen: exit;
      }
  
    ServerStatementHandle=serverS; //we will pass this reference to server in future calls
    
  }

  //todo destroy should call close
  
  protected void doPrepare(String sql) throws SQLException {
    short resSet;

    String colName;
    short x;
    short y;
    
    //debug
    GlobalUtil.logError("preparing "+sql);
    lastSQL=sql;
    
    /*call server prepare*/
    //todo Replace all AS with casts - speed
      fCon.marshalBuffer.ClearToSend();
      /*Note: because we know these marshalled parameters all fit in a buffer together,
       and because the buffer is now empty after the clearToSend,
       we can omit the error result checking in the following put() calls = speed
      */
      fCon.marshalBuffer.putFunction(Global.SQL_API_SQLPREPARE);
      fCon.marshalBuffer.putSQLHSTMT(ServerStatementHandle);
      fCon.marshalBuffer.putpUCHAR_SDWORD(sql);
      if (fCon.marshalBuffer.Send()!=Global.ok) {
        throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
      }  
      
      /*Wait for response*/
      if (fCon.marshalBuffer.Read()!=Global.ok) {
        throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
      }  
      /*Note: because we know these marshalled parameters all fit in a buffer together,
       and because the buffer has been read in total by the Read above because its size was known,
       we can omit the error result checking in the following get() calls = speed
      */
      functionId=fCon.marshalBuffer.getFunction();
      if (functionId!=Global.SQL_API_SQLPREPARE) {
        GlobalUtil.logError("Failed functionId="+functionId);
        throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
      }  
      resultCode=fCon.marshalBuffer.getRETCODE();
      //result:=resultCode; //pass it on //todo fix for DBX first!!!!!
      GlobalUtil.logError("prepare actually returns "+resultCode);

      /*if error, then get error details: local-number, default-text*/
      int errCount=fCon.marshalBuffer.getSQLINTEGER(); //error count
      //GlobalUtil.logError("prepare actually returns errorcount="+resultErrCode);
      if (resultCode==Global.SQL_ERROR) {
        for (int err=1;err<=errCount;err++) {
          //GlobalUtil.logError("getting server error "+err+" of "+resultErrCode);
          resultErrCode=fCon.marshalBuffer.getSQLINTEGER();
          resultErrText=fCon.marshalBuffer.getpUCHAR_SWORD();
          GlobalUtil.logError("server error "+err+"="+resultErrText);
        }
        //todo remove: never will happen: exit;
      }
 
      //todo remove getSQLHSTMT(planHandle);
      resSet=fCon.marshalBuffer.getSQLUSMALLINT();
      /*Remember this for future state changes*/
      if (resSet==Global.SQL_TRUE) {
        resultSet=true; 
      } else {
        resultSet=false;
      }
  
      GlobalUtil.logError("prepare returns "+resultCode+" "+resSet);
  
      if (resultCode==Global.SQL_ERROR) { //todo and any other bad return value possible: use case? 
        //todo remove-done above: s.diagnostic.logError(ss42000,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo too vague! todo correct?pass details! //todo check result
        //todo maybe server should send details along...
        
        //todo throw something else...
        throw new SQLException (resultErrText,Global.ss42000,resultErrCode);     
      }
      //todo remove! s.ServerStatementHandle:=planHandle; //store server's handle for future calls
      //todo I think we should store the StatementText against the stmt - may need later...
      // - although may be obtainable from server later?
      if (resultSet) {
        /*Now get the cursor column count & definitions*/
        colCount=fCon.marshalBuffer.getSQLINTEGER();
        GlobalUtil.logError("SQLPrepare returns "+colCount+" column defs");
        //todo rest is switchable? - maybe can defer till needed?
        //todo now use get with result checking!!!
        int i=0;
        while (i<=colCount-1) {
          //todo maybe server should sort by col-ref before sending?, although we sort here via getRecord...
          short rn=fCon.marshalBuffer.getSQLSMALLINT();
          GlobalUtil.logError("  reading column def "+rn);
          if (rn<=col.length) {
              col[rn-1/*-1 for Java*/].iFldNum=rn;
              /*We first read the name, type, precision and scale
               and then we make sure the correct parts of the descriptor are
               set according to the type*/
              col[rn-1/*-1 for Java*/].colName=fCon.marshalBuffer.getpSQLCHAR_SWORD();              
  
              x=fCon.marshalBuffer.getSQLSMALLINT();
              col[rn-1/*-1 for Java*/].iFldType=x;
  
              if (fCon.serverCLIversion>=93) {
                col[rn-1/*-1 for Java*/].iUnits1=fCon.marshalBuffer.getSQLINTEGER(); //=server width
              } 
              else {
                x=fCon.marshalBuffer.getSQLSMALLINT(); //=server width
                col[rn-1/*-1 for Java*/].iUnits1=x;
              }
              col[rn-1/*-1 for Java*/].iUnits2=fCon.marshalBuffer.getSQLSMALLINT();
              x=fCon.marshalBuffer.getSQLSMALLINT();
              col[rn-1/*-1 for Java*/].iNullOffset=x;
  
              GlobalUtil.logError("SQLPrepare read column definition: "+col[rn-1/*-1 for Java*/].colName+" ("+col[rn-1/*-1 for Java*/].iUnits1+")"); //todo debug only - remove
  
              //todo! iFldType=convertType(iFldType,iSubType);
          }
          else {
            //error, skip this column: need to consume the rest of this column definition anyway -> sink
            //todo or, could abort the whole routine instead?
            //note: currently getRecord cannot fail!
            GlobalUtil.logError("SQLPrepare failed getting desc record "+rn+" - rest of column defs abandoned..."); //todo debug error only - remove
            //todo throw something else?
            throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
          }
  
          i++;
        }
      }
      else { //no result set
      } //result set check
  
      /*Now get the param count & definitions*/
      paramCount=fCon.marshalBuffer.getSQLINTEGER();
      GlobalUtil.logError("SQLPrepare returns "+paramCount+" parameter defs"); //todo debug error only - remove
      //todo now use get with result checking!!!
      int i=0;
      while (i<=paramCount-1) {
        //todo maybe server should sort by param-ref before sending?, although we sort here via getRecord...
        short rn=fCon.marshalBuffer.getSQLSMALLINT();
        //todo if auto-ipd is switched off then
        // either set dr to a dummy-sink or
        // get all the parameter definitions into local dummy variables
        // - the server passes back the definition no matter what the driver switch is set to
        // - I think we should always auto-set the IPD count anyway?
  
        //todo since server doesn't yet give us any decent type info for the
        // parameters, we shouldn't overwrite any details that the user has
        // set - maybe don't use the server info if dataPtr has been set by user *******
  
        if (rn<=param.length) {
            param[rn-1/*-1 for Java*/].iParamNum=rn;
            /*We first read the name, type, precision and scale
             and then we make sure the correct parts of the descriptor are
             set according to the type*/
            param[rn-1/*-1 for Java*/].colName=fCon.marshalBuffer.getpSQLCHAR_SWORD();              
            
            //todo get desc_base_column_name as well...and catalog,schema,table!
            x=fCon.marshalBuffer.getSQLSMALLINT();
            param[rn-1/*-1 for Java*/].iDataType=x; //todo! TFieldType(convertType(x,y{dummy}));
  
            param[rn-1/*-1 for Java*/].iArgType=Global.ptInput; //default
  
            if (fCon.serverCLIversion>=93) {
              param[rn-1/*-1 for Java*/].iUnits1=fCon.marshalBuffer.getSQLINTEGER(); //=server width
            } 
            else {
              x=fCon.marshalBuffer.getSQLSMALLINT(); //=server width
              param[rn-1/*-1 for Java*/].iUnits1=x;
            }
            param[rn-1/*-1 for Java*/].iUnits2=fCon.marshalBuffer.getSQLSMALLINT();
            x=fCon.marshalBuffer.getSQLSMALLINT();
            //n/a param[rn].iNullOffset:=x;
            
            GlobalUtil.logError("SQLPrepare read parameter definition: "+param[rn-1/*-1 for Java*/].colName+" ("+param[rn-1/*-1 for Java*/].iUnits1+")"); //todo debug only - remove               
        } else {
          //error, skip this parameter: need to consume the rest of this parameter definition anyway -> sink
          //todo or, could abort the whole routine instead?
          //note: currently getRecord cannot fail!
          GlobalUtil.logError("SQLPrepare failed getting desc record "+rn+" - rest of parameter defs abandoned..."); //todo debug error only - remove
          //todo throw something else?
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
  
        i++;
      }
  
      /*todo remove? here
      {Now auto-bind all the columns}
      for i:=1 to colCount do
      begin
        ClearToSend;
        {Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer is now empty after the clearToSend,
         we can omit the error result checking in the following put() calls = speed
        }
        //note: it might be easier just to pass serverStmt,recordNumber,bound(T or F)
        //but we're trying to keep this function the same on the server in case we need it for other things...
        // - we could always call a special serverBindCol routine here instead?
        putFunction(SQL_API_SQLSETDESCFIELD);
        putSQLHSTMT(ServerStatementHandle); //pass server statement ref (it has no concept of our desc's)
        putSQLSMALLINT(col[i].iFldType); //todo don't really need this since server only cares about us setting its ARD responsibilities (currently...)
        //together, the above two are the server's closest concept of our DescriptorHandle
        putSQLSMALLINT(col[i].iFldNum); //this will be the colRef(-1) on the server
        putSQLSMALLINT(SQL_DESC_DATA_POINTER); //=SQL_DESC_DATA_POINTER
        putSQLPOINTER(SQLPOINTER(1){server could tell we are DBXpress if all bindings are to 1!}); //= 0=unbound, else bound
        putSQLINTEGER(col[i].iUnits1{todo:better to set & use iLen?});
        //we send Value (& BufferLength) even though it means nothing to the server,
        // - the server just needs to know if it's 0 or not to be able to track the bind/unbinds
        // although it might help for debugging/error reporting/comparing colBound values? - not used for such yet...
        if Send<>ok then
        begin
          result:=SQL_ERROR2;
          logError(ss08S01);
          exit;
        end;
  
        {Wait for response}
        if Read<>ok then
        begin
          result:=SQL_ERROR2;
          logError(ssHYT00);
          exit;
        end;
        {Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer has been read in total by the Read above because its size was known,
         we can omit the error result checking in the following get() calls = speed
        }
        getFunction(functionId);
        if functionId<>SQL_API_SQLSETDESCFIELD then
        begin
          result:=SQL_ERROR2;
          logError(ss08S01);
          exit;
        end;
        getRETCODE(resultCode);
        //todo remove result:=resultCode; //pass it on //todo fix first for DBX!
        {Translate result}
        case resultCode of
          SQL_ERROR: result:=SQL_ERROR2;
        else
          result:=SQL_SUCCESS; //DBX ignores warnings etc.
        end; {case}
        {$IFDEF DEBUG_LOG}
        log(format('prepare bound column %d (%d) returns %d',[i,col[i].iFldNum,resultCode]),vLow);
        {$ENDIF}
        {if error, then get error details: local-number, default-text}
        if getSQLINTEGER(resultErrCode)<>ok then exit; //error count
        if resultCode=SQL_ERROR then
        begin
          for err:=1 to resultErrCode do
          begin
            if getSQLINTEGER(resultErrCode)<>ok then exit;
            if getpUCHAR_SWORD(pUCHAR(resultErrText),DYNAMIC_ALLOCATION,tempsw)<>ok then exit;
            case resultErrCode of
              seInvalidHandle:         result:=DBXERR_INVALIDHNDL;
              seNotPrepared:           result:=SQL_ERROR2;
              seColumnNotBound:        result:=SQL_ERROR2;
              seColumnAlreadyBound:    result:=SQL_ERROR2;
              seUnknownFieldId:        result:=SQL_ERROR2;
            else
              result:=SQL_ERROR2;
            end; {case}
            logError(resultErrText);
            if resultErrText<>nil then freeMem(resultErrText); //todo safe without length?
          end;
          exit;
        end;
      end; {for}
      */
  }

  protected void doExecute() throws SQLException {
    short lateResSet;

    String colName;
    short x;
    short y;
    short tempNull;
    
    fCon.marshalBuffer.ClearToSend();
    /*Note: because we know these marshalled parameters all fit in a buffer together,
     and because the buffer is now empty after the clearToSend,
     we can omit the error result checking in the following put() calls = speed
    */
    fCon.marshalBuffer.putFunction(Global.SQL_API_SQLEXECUTE);
    fCon.marshalBuffer.putSQLHSTMT(ServerStatementHandle); //pass server statement ref

    //todo send parameter data - could be array & have offset etc.
    // - reverse logic used in fetchScroll... (after it's complete!)
    //Note: here is where we implicitly convert the valueType(client) into the ParamType(server)

    /* todo implement when server can accept parameter arrays
       for now, we restrict PARAMSET_SIZE = 1
    */
    //for now:
    int rowCount=1; //todo get from PARAMSET_SIZE, may as well since it's always 1

    //Write row count
    fCon.marshalBuffer.putSQLUINTEGER(rowCount);
    //todo? check rowCount=array_size - no reason why not... could assume? - but dangerous
    /*Initialise the count of non-empty param (rows?) in the application's buffer*/
    //if s.apd.desc_rows_processed_ptr<>nil then
    //  pSQLuINTEGER(s.apd.desc_rows_processed_ptr)^:=0; //we increment this each time we send a 'real' param row
    //might be slightly quicker (less safe) to set to rowCount now & decrement if we get an empty/bad row - speed?

    //todo: note pSQLINTEGER(intPtr)^:=x is safer than SQLINTEGER(intPtr^):=x
    // - check this is true & if so make sure we use this everywhere!

    //if s.apd.desc_bind_offset_ptr<>nil then
    //  offsetSize:=SQLINTEGER(s.apd.desc_bind_offset_ptr^) //get deferred value
    //else
      int offsetSize=0; //todo assert rowCount/array_size = 1 - else where do we get the data!!!!

    short setStatusExtra=0; //no conversion errors

    for (int row=1; row<=rowCount; row++) {
      //Now send the param count & data for this row
      fCon.marshalBuffer.putSQLINTEGER(paramCount); //note: this may no longer match server's count! //todo ok/disallow?
                                 // or should we always use s.ipd.desc_count?
      //todo assert s.apd.desc_count(<?)=s.ipd.desc_count ?
      //todo now use put with result checking!!!

      short rowStatusExtra=0; //no conversion errors

      int i=0;
      while (i<=paramCount-1) {
        //with param[i+1] do
          GlobalUtil.logError("execute sending parameter "+(i+1)+" data: "+param[i/*+1 removed for Java*/].buffer.length()/*todo bufferLen*/+" bytes"); //todo debug only
          //todo maybe server should sort by param-ref after receiving?, although we sort here via getRecord...
          fCon.marshalBuffer.putSQLSMALLINT((short)(i+1));
          //todo if this has just been created, then problem - can't happen if we assert desc_count<colCount above?
            //todo use a put routine that doesn't add \0 = waste of space at such a raw level?
            //todo check casts are ok
            //todo assert desc_data_ptr<>nil! surely not every time!?
            
            /* Put the data */
            
            //we need to store pointer in a temp var cos we need to pass as var next (only because routine needs to allow Dynamic allocation - use 2 routines = speed)
              //todo - doesn't apply to put - remove need here in parameter sending routine! -speed
            //elementSize may not be original desc_octet_length if fixed-length data-type, but bindCol fixes it for us
                //-> todo: if we start to use arrays of parameters - need to ensure desc_octet_length is set to size of fixed types during bindParameter/setdescField
            //if s.apd.desc_bind_type=SQL_BIND_BY_COLUMN then //column-wise //todo move this if outside loop -speed
            //  dataPtr:=pUCHAR(SQLHDESC(desc_data_ptr)+offsetSize+( (row-1)* desc_octet_length))
            //else //row-wise
            //  dataPtr:=pUCHAR(SQLHDESC(desc_data_ptr)+offsetSize+( (row-1)* s.apd.desc_bind_type));

            //todo convert from c to server type (i.e. from APD to IPD) ******
            // - note do before we modify send buffer area - may be too big!
            /*todo remove
            if s.ipd.getRecord(i+1,Idr,True)<>ok then
            begin
              //error, skip this parameter: need to send the rest of this parameter definition anyway -> dummy
              //todo or, could abort the whole routine instead?
              //note: currently getRecord cannot fail!
              {$IFDEF DEBUGDETAIL}
              log(format('SQLExecute failed getting IPD desc record %d - rest of parameter data abandoned...',[i+1])); //todo debug error only - remove
              {$ENDIF}
              result:=SQL_ERROR;
              s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
              exit; //todo: just for now!
            end;
            */

            /*Put the null flag*/
            tempNull=Global.SQL_FALSE; //default
            if (param[i/*+1 removed for Java*/].isNull) { tempNull=Global.SQL_TRUE; }
            fCon.marshalBuffer.putSQLSMALLINT(tempNull);

            //tempsdw:=0; //todo: remove: only set for debug message below -speed

            if (tempNull==Global.SQL_FALSE) {
              //Note: we only send length+data if not null
              
              /*Set tempsdw to the length - may be modified by conversion routines*/
              
              //todo maybe don't set tempsdw if null will be set below?
              //tempsdw:=bufferLen;
              
              /*If this is a fixed type, we ignore the passed BufferLength & use our own*/ //todo is this the best place for this?
              
//todo debug only!!!!! copied from BindCol...
              //todo copy this code to BindParameter?
              //FixBufferLen(desc_type,tempsdw);
              //todo if DATA_AT_EXEC then pass data_pointer to server - it will return it when data required
              //-no: we have then server return the param-ref & we return the data_pointer locally

              //case desc.iDataType of
                //todo: for now we only get/return string params
                //fldZSTRING:
                  //assume buffer is already a string
                  //todo remove: replaced to allow blob segmentation: fCon.marshalBuffer.putpUCHAR_SDWORD(param[i/*+1 removed for Java*/].buffer);
                  fCon.marshalBuffer.putpDataSDWORD(param[i/*+1 removed for Java*/].buffer.getBytes());
              //end; {case}

              /*todo remove
              //note: SQL_C_DEFAULT could be dangerous - we assume user knows what they're doing!
              if not isBinaryCompatible(Idr.desc_concise_type,desc_concise_type) then
              begin //conversion required
                (* todo remove, we don't know it yet
                {We read the 1st part, the length, of the field}
                if getSDWORD(tempsdw)<>ok then
                begin
                  result:=SQL_ERROR;
                  s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
                  exit;
                end;
                *)
                {Remember any result (error or warning) to add to rowStatus returned from server}
                colStatusExtra:=putAndConvert(Adr,Idr.desc_concise_type, dataPtr,tempsdw {todo replaced desc_octet_length},
                                (s.owner as Tdbc).Marshal,tempsdw {todo no need here/or just here!?}, s.diagnostic,row,i+1);
                if colStatusExtra<>ok then
                  if rowStatusExtra=0 then
                    rowStatusExtra:=colStatusExtra; //note: we only retain the 1st warning or error (todo check ok with standard)
                                                    //(although multiple diagnostic error may have been stacked)

                //todo ensure that if a fixed-size result is null, the put in putandconvert doesn't send too much!!!
                //********* i.e. we should always send a int/float value even if null
                //          or we should send null flag first before sending data
                //          or putandconvert should not put if tempsdw=0 is passed!
                //     Note: we do the 3rd option - check works ok...

                //todo check no need: marshal.skip(tempsdw); //just read by another routine!
              end
              else
              begin //no conversion required
                //note: we don't add \0 here
                //todo we should if user has given len=NTS!!!!!!!! ***
                // -is there an inverse rule to this for the receival side(fetch)?
                if putpDataSDWORD(dataPtr,tempsdw{todo replaced desc_octet_length})<>ok then
                begin
                  result:=SQL_ERROR;
                  s.diagnostic.logError(ss08S01,fail,'',SQL_NO_ROW_NUMBER,SQL_NO_COLUMN_NUMBER); //todo check result
                  exit;
                end;
              end;
              */
            }

            GlobalUtil.logError("execute sent parameter "+(i+1)+" data: "+param[i/*+1 removed for Java*/].buffer.length()/*todo bufferLen*/+" bytes, null="+tempNull); //todo debug only
        i++;
      } //while
      /* //these need to be inverted if/when we allow parameters arrays
      {put row status}
      getSQLUSMALLINT(sqlRowStatus);
      {$IFDEF DEBUGDETAIL}
      log(format('SQLFetchScroll read row status %d: %d',[rn,sqlRowStatus])); //todo debug only - remove & assumes null terminated pCHAR! which it is from get routines...
      {$ENDIF}
      {If there was a conversion error, then we set the SQLrowStatus to it
       todo - check ok with standard!}
      if rowStatusExtra<>0 then
      begin
        sqlRowStatus:=rowStatusExtra; //todo: maybe we should only if sqlRowStatus is 'OK'?
        if setStatusExtra=0 then
          setStatusExtra:=rowStatusExtra;
      end;
      if s.ard.desc_array_status_ptr<>nil then
      begin
        //todo remove & statusPtr var: statusPtr:=pSQLUSMALLINT(longint(desc_array_status_ptr)+( (row-1)* sizeof(SQLUSMALLINT)))
        SQLUSMALLINT(pSQLUSMALLINT(longint(s.ard.desc_array_status_ptr)+( (row-1)* sizeof(SQLUSMALLINT)))^):=sqlRowStatus;
      end;
      */
      
      /*Add to the count of non-empty param rows in the application's buffer*/
    //todo reinstate when arrays are allowed:   if sqlRowStatus<>SQL_ROW_NOROW then

      //  if s.apd.desc_rows_processed_ptr<>nil then
      //    inc(pSQLuINTEGER(s.apd.desc_rows_processed_ptr)^); //we increment this each time we put a (todo remove?'real') param row
    } //for row

    if (fCon.marshalBuffer.Send()!=Global.ok) {
      throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
    }  
      
    /*Wait for response*/
    if (fCon.marshalBuffer.Read()!=Global.ok) {
      throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
    }  
    /*Note: because we know these marshalled parameters all fit in a buffer together,
     and because the buffer has been read in total by the Read above because its size was known,
     we can omit the error result checking in the following get() calls = speed
    */
    functionId=fCon.marshalBuffer.getFunction();
    if (functionId!=Global.SQL_API_SQLEXECUTE) {
      GlobalUtil.logError("doExecute: Failed functionId="+functionId);
      throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
    }  
    resultCode=fCon.marshalBuffer.getRETCODE();
    //result:=resultCode; //pass it on //todo fix for DBX first!!!!!
    GlobalUtil.logError("execute actually returns "+resultCode);

    /*if error, then get error details: local-number, default-text*/
    int errCount=fCon.marshalBuffer.getSQLINTEGER(); //error count
    if (resultCode==Global.SQL_ERROR) {
      for (int err=1;err<=errCount;err++) {
        resultErrCode=fCon.marshalBuffer.getSQLINTEGER();
        resultErrText=fCon.marshalBuffer.getpUCHAR_SWORD();
        GlobalUtil.logError("server error="+resultErrText);
      }
      //todo remove: never will happen: exit;
    }

    /*Get the row count - only valid for insert/update/delete*/
    int resultRowCount=fCon.marshalBuffer.getSQLINTEGER();
    affectedRowCount=resultRowCount; //todo get direct?
    
    if (fCon.serverCLIversion>=92) {
      /*Now get any late (post-prepare) resultSet definition, i.e. for stored procedure return cursors
        False here doesn't mean we have no result set, it means we should use the details from SQLprepare*/
      lateResSet=fCon.marshalBuffer.getSQLUSMALLINT();
      /*Remember this for future state changes*/
      if (lateResSet==Global.SQL_TRUE) {
        resultSet=true; 
      } //else leave resultSet as was
  
      GlobalUtil.logError("execute returns "+resultCode+" "+lateResSet);
  
      if (lateResSet==Global.SQL_TRUE) {
        /*Now get the cursor column count & definitions*/
        colCount=fCon.marshalBuffer.getSQLINTEGER();
        GlobalUtil.logError("SQLExecute returns "+colCount+" column defs");
        //todo rest is switchable? - maybe can defer till needed?
        //todo now use get with result checking!!!
        int i=0;
        while (i<=colCount-1) {
          //todo maybe server should sort by col-ref before sending?, although we sort here via getRecord...
          short rn=fCon.marshalBuffer.getSQLSMALLINT();
          GlobalUtil.logError("  reading column def "+rn);
          if (rn<=col.length) {
              col[rn-1/*-1 for Java*/].iFldNum=rn;
              /*We first read the name, type, precision and scale
               and then we make sure the correct parts of the descriptor are
               set according to the type*/
              col[rn-1/*-1 for Java*/].colName=fCon.marshalBuffer.getpSQLCHAR_SWORD();              
  
              x=fCon.marshalBuffer.getSQLSMALLINT();
              col[rn-1/*-1 for Java*/].iFldType=x;
  
              if (fCon.serverCLIversion>=93) {
                col[rn-1/*-1 for Java*/].iUnits1=fCon.marshalBuffer.getSQLINTEGER(); //=server width
              } 
              else {
                tempNull=fCon.marshalBuffer.getSQLSMALLINT(); //=server width
                col[rn-1/*-1 for Java*/].iUnits1=tempNull;
              }

              col[rn-1/*-1 for Java*/].iUnits2=fCon.marshalBuffer.getSQLSMALLINT();
              x=fCon.marshalBuffer.getSQLSMALLINT();
              col[rn-1/*-1 for Java*/].iNullOffset=x;
  
              GlobalUtil.logError("SQLExecute read column definition: "+col[rn-1/*-1 for Java*/].colName+" ("+col[rn-1/*-1 for Java*/].iUnits1+")"); //todo debug only - remove
  
              //todo! iFldType=convertType(iFldType,iSubType);
          }
          else {
            //error, skip this column: need to consume the rest of this column definition anyway -> sink
            //todo or, could abort the whole routine instead?
            //note: currently getRecord cannot fail!
            GlobalUtil.logError("SQLExecute failed getting desc record "+rn+" - rest of column defs abandoned..."); //todo debug error only - remove
            //todo throw something else?
            throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
          }
  
          i++;
        }
      }
      //else no late result set: leave as was
    }
    //else young server cannot handle this
    
    switch (resultCode) {
      case Global.SQL_SUCCESS:
      case Global.SQL_SUCCESS_WITH_INFO:
      {
        //todo get rowCount
        //todo get command-type & store locally somewhere...
        //todo if update/delete affected 0 rows, we need to return SQL_NO_DATA

        //we SQLendTran now if in autocommit mode & if not select/result-set
        if (!resultSet && fCon.fAutocommit) {
          fCon.commit();
        }

        /*Build & return resultSet*/
        fResultSet=new ResultSetSQL(this);
        /*Translate result*/
        
        break;
      }; //SQL_SUCCESS, SQL_SUCCESS_WITH_INFO
      case Global.SQL_NEED_DATA:
      {
        if (prepared) { //Note: could be called from SQLexecDirect so behaves as if prepared...
          /*Get the next missing parameter reference from the server*/
          short rn=fCon.marshalBuffer.getSQLSMALLINT();
          /*but we can't return it to the user here - they must call SQLParamData to get it*/
          //todo could save 1st call to SQLparamData from contacting server!!!! - speed
        }
        else
        { //should never happen unless caller doesn't know the rules, but then how could we get to need data if we weren't prepared?
          throw new SQLException (resultErrText,Global.ssHY010,resultErrCode);    //todo fix error text 
        }
        
        break;
      }; //SQL_NEED_DATA
      case Global.SQL_STILL_EXECUTING:
      {
        break;
      }; //SQL_STILL_EXECUTING
      case Global.SQL_ERROR:
      {
        if (prepared) { //Note: could be called from SQLexecDirect so caller will need to move from S2 to S1
        }
        else
        {
          throw new SQLException (resultErrText,Global.ssHY000,resultErrCode);     
        };
        
        break;
      }; //SQL_ERROR
    default:
      //todo what if SQL_ERROR?
      //(else) should never happen!?
    } //switch
    
    
  }


    /**
     * Execute a SQL statement that returns a single ResultSet.
     *
     * @param sql typically this is a static SQL SELECT statement
     * @return a ResultSet that contains the data produced by the
     * query; never null 
     */
    public ResultSet executeQuery(String sql) throws SQLException {
      //todo also create resultSetMetaData attached to resultSet
      
      //try {
        if (fResultSet!=null) {
          fResultSet.close(); //close any previous resultSet before creating a new one //todo any need? automatic on resultSet.close?
          fResultSet=null;
        }
        
        doPrepare(sql);       
        doExecute();
        //todo check resultSet, else exception!?
        return fResultSet;
      //}
      //catch (SQLException e) {
      //  throw new SQLException ();
      //}
    }

    /**
     * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
     * SQL statements that return nothing such as SQL DDL statements
     * can be executed.
     *
     * @param sql a SQL INSERT, UPDATE or DELETE statement or a SQL
     * statement that returns nothing
     * @return either the row count for INSERT, UPDATE or DELETE or 0
     * for SQL statements that return nothing
     */
    public int executeUpdate(String sql) throws SQLException {
      //try {
        if (fResultSet!=null) {
          fResultSet.close(); //close any previous resultSet before creating a new one //todo: we could allow update/insert/deletes & keep one open resultSet... //todo any need? automatic on resultSet.close?
          fResultSet=null;
        }
        
        doPrepare(sql);       
        doExecute();
        //todo check !resultSet, else exception!?
        return affectedRowCount;
      //}
      //catch (SQLException e) {
      //  throw new SQLException ();
      //}
    }

    /**
     * In many cases, it is desirable to immediately release a
     * Statements's database and JDBC resources instead of waiting for
     * this to happen when it is automatically closed; the close
     * method provides this immediate release.
     *
     * <P><B>Note:</B> A Statement is automatically closed when it is
     * garbage collected. When a Statement is closed, its current
     * ResultSet, if one exists, is also closed.  
     */
    public void close() throws SQLException {
      //todo move close code here... any need? //todo any need? automatic?
      if (fResultSet!=null) {
        fResultSet.close();
        fResultSet=null;
      }
      
      if (ServerStatementHandle<=0) {
        GlobalUtil.logError("resultSet(stmt) already closed - ignoring");
      }
      else {
      //todo split the close into resultset/stmt close?
      /*Free the server handle*/
        GlobalUtil.logError("resultSet(stmt) closing...3");
        fCon.marshalBuffer.ClearToSend();
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer is now empty after the clearToSend,
         we can omit the error result checking in the following put() calls = speed
        */
        fCon.marshalBuffer.putFunction(Global.SQL_API_SQLFREEHANDLE);
        fCon.marshalBuffer.putSQLSMALLINT(Global.SQL_HANDLE_STMT);
        fCon.marshalBuffer.putSQLHSTMT(ServerStatementHandle); //pass server statement ref
        if (fCon.marshalBuffer.Send()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
    
        /*Wait for response*/
        if (fCon.marshalBuffer.Read()!=Global.ok) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        /*Note: because we know these marshalled parameters all fit in a buffer together,
         and because the buffer has been read in total by the Read above because its size was known,
         we can omit the error result checking in the following get() calls = speed
        */
        GlobalUtil.logError("resultSet(stmt) closing...4");
        functionId=fCon.marshalBuffer.getFunction();
        if (functionId!=Global.SQL_API_SQLFREEHANDLE) {
          throw new SQLException (Global.seConnectionFailedText,Global.ss08S01,Global.seConnectionFailed);     
        }
        resultCode=fCon.marshalBuffer.getRETCODE();
        /*if error, then get error details: local-number, default-text*/
        int errCount=fCon.marshalBuffer.getSQLINTEGER(); //error count
        if (resultCode==Global.SQL_ERROR) {
          for (int err=1;err<=errCount;err++) {
            resultErrCode=fCon.marshalBuffer.getSQLINTEGER();
            resultErrText=fCon.marshalBuffer.getpUCHAR_SWORD();
            GlobalUtil.logError("server error="+resultErrText);
          }
          //todo remove: never will happen: exit;
        }
        
        ServerStatementHandle=-1; //not connected //todo only if ok result?
      }
    }

    //----------------------------------------------------------------------

    /**
     * The maxFieldSize limit (in bytes) is the maximum amount of data
     * returned for any column value; it only applies to BINARY,
     * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
     * columns.  If the limit is exceeded, the excess data is silently
     * discarded.
     *
     * @return the current max column size limit; zero means unlimited 
     */
    public int getMaxFieldSize() throws SQLException {
      return 0;
    }
    
    /**
     * The maxFieldSize limit (in bytes) is set to limit the size of
     * data that can be returned for any column value; it only applies
     * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
     * LONGVARCHAR fields.  If the limit is exceeded, the excess data
     * is silently discarded. For maximum portability use values
     * greater than 256.
     *
     * @param max the new max column size limit; zero means unlimited 
     */
    public void setMaxFieldSize(int max) throws SQLException {
    }

    /**
     * The maxRows limit is the maximum number of rows that a
     * ResultSet can contain.  If the limit is exceeded, the excess
     * rows are silently dropped.
     *
     * @return the current max row limit; zero means unlimited
     */
    public int getMaxRows() throws SQLException {
      return 0;
    }

    /**
     * The maxRows limit is set to limit the number of rows that any
     * ResultSet can contain.  If the limit is exceeded, the excess
     * rows are silently dropped.
     *
     * @param max the new max rows limit; zero means unlimited 
     */
    public void setMaxRows(int max) throws SQLException {
    }

    /**
     * If escape scanning is on (the default), the driver will do
     * escape substitution before sending the SQL to the database. 
     *
     * @param enable true to enable; false to disable
     */
    public void setEscapeProcessing(boolean enable) throws SQLException {
    }

    /**
     * The queryTimeout limit is the number of seconds the driver will
     * wait for a Statement to execute. If the limit is exceeded, a
     * SQLException is thrown.
     *
     * @return the current query timeout limit in seconds; zero means unlimited 
     */
    public int getQueryTimeout() throws SQLException {
      return 0;
    }

    /**
     * The queryTimeout limit is the number of seconds the driver will
     * wait for a Statement to execute. If the limit is exceeded, a
     * SQLException is thrown.
     *
     * @param seconds the new query timeout limit in seconds; zero means unlimited 
     */
    public void setQueryTimeout(int seconds) throws SQLException {
    }

    /**
     * Cancel can be used by one thread to cancel a statement that
     * is being executed by another thread.
     */
    public void cancel() throws SQLException {
      throw new SQLException (Global.seNotImplementedYetText,Global.ssHYC00,Global.seNotImplementedYet);     
    }

    /**
     * The first warning reported by calls on this Statement is
     * returned.  A Statment's execute methods clear its SQLWarning
     * chain. Subsequent Statement warnings will be chained to this
     * SQLWarning.
     *
     * <p>The warning chain is automatically cleared each time
     * a statement is (re)executed.
     *
     * <P><B>Note:</B> If you are processing a ResultSet then any
     * warnings associated with ResultSet reads will be chained on the
     * ResultSet object.
     *
     * @return the first SQLWarning or null 
     */
    public SQLWarning getWarnings() throws SQLException {
      return null;
    }

    /**
     * After this call, getWarnings returns null until a new warning is
     * reported for this Statement.  
     */
    public void clearWarnings() throws SQLException {
    }

    /**
     * setCursorname defines the SQL cursor name that will be used by
     * subsequent Statement execute methods. This name can then be
     * used in SQL positioned update/delete statements to identify the
     * current row in the ResultSet generated by this statement.  If
     * the database doesn't support positioned update/delete, this
     * method is a noop.
     *
     * <P><B>Note:</B> By definition, positioned update/delete
     * execution must be done by a different Statement than the one
     * which generated the ResultSet being used for positioning. Also,
     * cursor names must be unique within a Connection.
     *
     * @param name the new cursor name.  
     */
    public void setCursorName(String name) throws SQLException {
    }
	
    //----------------------- Multiple Results --------------------------

    /**
     * Execute a SQL statement that may return multiple results.
     * Under some (uncommon) situations a single SQL statement may return
     * multiple result sets and/or update counts.  Normally you can ignore
     * this, unless you're executing a stored procedure that you know may
     * return multiple results, or unless you're dynamically executing an
     * unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
     * and "getUpdateCount" methods let you navigate through multiple results.
     *
     * The "execute" method executes a SQL statement and indicates the
     * form of the first result.  You can then use getResultSet or
     * getUpdateCount to retrieve the result, and getMoreResults to
     * move to any subsequent result(s).
     *
     * @param sql any SQL statement
     * @return true if the next result is a ResultSet; false if it is
     * an update count or there are no more results
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults 
     */
    public boolean execute(String sql) throws SQLException {
      //try {
        if (fResultSet!=null) {
          fResultSet.close(); //close any previous resultSet before creating a new one //todo: we could allow update/insert/deletes & keep one open resultSet... //todo any need? automatic on resultSet.close?
          fResultSet=null;
        }
        
        doPrepare(sql);       
        doExecute();
        
        return resultSet; //true or false
      //}
      //catch (SQLException e) {
      //  throw new SQLException ();
      //}
    }
	
    /**
     *  getResultSet returns the current result as a ResultSet.  It
     *  should only be called once per result.
     *
     * @return the current result as a ResultSet; null if the result
     * is an update count or there are no more results
     * @see #execute 
     */
    public ResultSet getResultSet() throws SQLException {
      return fResultSet;
    }

    /**
     *  getUpdateCount returns the current result as an update count;
     *  if the result is a ResultSet or there are no more results, -1
     *  is returned.  It should only be called once per result.
     * 
     * @return the current result as an update count; -1 if it is a
     * ResultSet or there are no more results
     * @see #execute 
     */
    public int getUpdateCount() throws SQLException {
      if (resultSet) {
        return -1;
      } else {
        return affectedRowCount;
      }
    }

    /**
     * getMoreResults moves to a Statement's next result.  It returns true if 
     * this result is a ResultSet.  getMoreResults also implicitly
     * closes any current ResultSet obtained with getResultSet.
     *
     * There are no more results when (!getMoreResults() &&
     * (getUpdateCount() == -1)
     *
     * @return true if the next result is a ResultSet; false if it is
     * an update count or there are no more results
     * @see #execute 
     */
    public boolean getMoreResults() throws SQLException {
      /* todo: we should close the current result set here, so (!getMoreResults() && (getUpdateCount() == -1) can become false
      */  
      return false;
    }
    
    //extra
    public void clearBatch() throws SQLException {
    }
  
    public Connection getConnection() throws SQLException {
      return fCon;
    }
    

    public void setFetchSize(int rows) throws SQLException {
    }


    public int getResultSetType() throws SQLException {
      return java.sql.ResultSet.TYPE_FORWARD_ONLY;
    }

    public int getFetchSize() throws SQLException {
      return 0;
    }
  
  
    public void setFetchDirection(int direction) throws SQLException {
    }
  
    public int getFetchDirection() throws SQLException {
      return java.sql.ResultSet.FETCH_FORWARD ;
    }  
      
    public int getResultSetConcurrency() throws SQLException {
      return java.sql.ResultSet.CONCUR_READ_ONLY;
    }
   
    public int[] executeBatch() throws SQLException {
      return null;
    }
  
    public void addBatch(String sql) throws SQLException {
      throw new SQLException (Global.seNotImplementedYetText,Global.ssHYC00,Global.seNotImplementedYet);     
    }




};

